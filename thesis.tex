% Related work:
% Object representation of scope during translation (coined "scope graph"):
%   http://www.lirmm.fr/~ducour/Doc-objets/ECOOP/papers/0276/02760071.pdf
% MetaOcaml & related work by Walid Taha
% Interesting sugary languages: Dylan, Julia, Nim
% From Joe, "See S8. And also the whole paper.":
%   https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf
% PHOAS?
%   Chipala ICFP'08 https://archive.alvb.in/msc/10_infomepcs1/literature/PHOAS_Chlipala.pdf
% Extensible Grammars for Language Specialization (must CITE)
%   Cardelli, Matthes, Abadi - DigEquipRC

\RequirePackage{silence} % :-\
    \WarningFilter{scrbook}{Usage of package `titlesec'}
    \WarningFilter{titlesec}{Non standard sectioning command detected}
\documentclass[
  11pt,
  paper=letter,
  footinclude=true,
  headinclude=true,
  american
]{scrbook}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Packages

\usepackage[T1]{fontenc}
\usepackage[
  linedheaders=true,
  parts=true
]{classicthesis/classicthesis} % ,manychapters

% More symbols
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
% More commands
\usepackage{xargs}
\usepackage{xspace}
\usepackage{xifthen}
% More environments
\usepackage{listings}
\usepackage{multicol}
\usepackage{alltt}
\usepackage{semantic}
\usepackage{bussproofs}
% More nice things
\usepackage{cleveref}
\usepackage{color}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Settings

% Colors
\definecolor{goodRed}{rgb} {0.70, 0.37, 0.41} % LAB (50, 35, 10)
\definecolor{goodBlue}{rgb}{0.04, 0.50, 0.70} % LAB (50, -10, -35)
\hypersetup{
  colorlinks=false,
  %citecolor=goodBlue,
  %linkcolor=goodRed
  citebordercolor=goodBlue,
  linkbordercolor=goodRed
}

% LstListing
\lstset{basicstyle=\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,frame=bottomline}

% Theorems
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Commands

% General Formatting
\newcommand{\Sc}[1]{\textsc{#1}\xspace}
\newcommand{\Desc}[1]{\noindent\textit{#1:} }
\newenvironment{Table}
  {\begin{center}\begin{tabular}{l l l @{\quad}l}}
  {\end{tabular}\end{center}}
\newenvironment{ProofTable}
  {~\\\begin{tabular}{r l @{\quad} l}}
  {\end{tabular}~\\}

% Math Notation
\newcommand{\ddd}{\;\dots\;}
\newcommand{\dd}{\,...\,}
\newcommand{\Exists}[1]{\exists{#1}.\,\,}
\newcommand{\ExistsUnique}[1]{\exists!{#1}.\,\,}
\newcommand{\NotExists}[1]{\not\exists{#1}.\,\,}
\newcommand{\Forall}[1]{\forall{#1}.\,\,}
\newcommand{\NotForall}[1]{\not\forall{#1}.\,\,}
\newcommand{\SetSuchThat}[2]{\{#1 \;|\; #2\}}
\newcommand{\DisjUnion}{\,\dot\cup\,}
\newcommand{\To}{\Rightarrow}

% Code notation
\newcommand{\Code}[1]{\texttt{#1}}
\newenvironment{Codes}
  {\begin{alltt}\leftskip=1.5em} % \small
  {\end{alltt}}

% PL Formatting
\newcommand{\TypeLabel}[2]{
  \setlength{\fboxsep}{2pt}\fbox{$#1 \mapsto #2$}
}

% PL Notation
\newcommand{\CoreStep}{{\rule{0pt}{1.2\baselineskip}{\ensuremath\longrightarrow}}}
\newcommand{\SurfStep}{{\rule{0pt}{1.2\baselineskip}{\ensuremath\dashrightarrow}}}
% (inference rules)
\newcommandx*{\Inference}[3][1=\empty]{\inference[#1]{#2}{#3}\vspace{1.5em}}
\newcommand{\IS}{\vspace{0.25em}} % Not enough space by default...

% Judgements
\newcommand{\SaysSubs}[4]{#1 \vdash #2 \bullet #3 = #4}
\newcommand{\SaysMatch}[4]{#1 \vdash #2 / #3 = #4}
\newcommand{\SaysExpr}[3]{#1 \vdash #2 : #3}
\newcommand{\SaysPatt}[4]{#1;#2 \vdash #3 : #4}
\newcommand{\SaysRule}[4]{#1 \vdash #2 : #3 \to #4}
\newcommand{\SaysEnv}[3]{#1 \vdash #2 : #3}
\newcommand{\SaysStep}[3]{#1 \vdash #2 \rightsquigarrow #3}
\newcommand{\SaysSteps}[3]{#1 \vdash #2 \rightsquigarrow^{*} #3}
\newcommand{\SaysCase}[4]{#1 \vdash #2 \rightsquigarrow #3 \text{ by  case } #4}
\newcommand{\SaysNotCase}[4]{#1 \not\vdash #2 \rightsquigarrow #3 \text{ by  case } #4}
\newcommand{\SaysScope}[6]{#1 \vdash #2 : #3 ; #4 ; #5 ; #6}
\newcommand{\SaysCanBind}[3]{#1 \vdash #2 \sim_{bind} #3}
\newcommand{\SaysCanShadow}[3]{#1 \vdash #2 \sim_{shadow} #3}

% Syntypes
\newcommand{\TRefn}{\textrm{Refn}}
\newcommand{\TDecl}{\textrm{Decl}}
\newcommand{\TString}{\textrm{String}}

% Scope
\newcommand{\Bind}[3]{\texttt{bind } #3 \texttt{ in } #2 \ensuremath{\in #1}}
\newcommand{\Prov}[2]{\texttt{provide } #2 \ensuremath{\in #1}}

% Expressions
\newcommand{\Core}[2]{\{#1\,#2\}}
\newcommand{\Surf}[2]{(#1\,#2)}
\newcommand{\Variable}[4]{
  {#3}\textrm{\textsc{$#2$}}_\mathit{#1}^\textsc{#4}}
\newcommandx*{\Decl}[3][1=\empty, 3=\empty]{\Variable{#1}{#2}{#3}{d}}
\newcommandx*{\Refn}[3][1=\empty, 3=\empty]{\Variable{#1}{#2}{#3}{r}}
% Patterns
\newcommand{\PVarA}{\alpha}
\newcommand{\PVarB}{\beta}
\newcommand{\PVarC}{\gamma}
% SeqPatterns
\newcommand{\Cons}[2]{#1, #2}
\newcommand{\Rep}[2]{#1\ {*}\_{#2}}
% Desugaring Rules
\newcommand{\DsRule}[2]{\Code{sugar}\;#1 = \{#2\}}
\newcommand{\DsRuleFancy}[3]{\Code{sugar}\;#1 =
  \begin{cases}
    #2 \\
    \quad ... \\
    #3
  \end{cases}
}
\newcommand{\DsRuleCase}[4]{#1;#2;#3 \To #4}
% Environments
\newcommand{\EmptyEnv}{\{\}}
\newcommand{\ConsEnv}[3]{#1:#2,\,#3}
% Substitutions
\newcommand{\EmptySubs}{\{\}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Terminology

\newcommand{\Constr}[2]{\ifthenelse{\isempty{#2}}{#1}{#1(#2)}}
\newcommand{\ConstrTt}[2]{\Constr{\texttt{#1}}{#2}}
\newcommand{\ConstrIt}[2]{\Constr{\textit{#1}}{#2}}
\newcommand{\ConstrCal}[2]{\Constr{\mathcal{#1}}{#2}}

\newcommand{\ConstrSub}[3]{\ifthenelse{\isempty{#2}}{#1}{#1_{#2}(#3)}}
\newcommand{\ConstrSubTt}[3]{\ConstrSub{\texttt{#1}}{#2}{#3}}
\newcommand{\ConstrSubIt}[3]{\ConstrSub{\textit{#1}}{#2}{#3}}
\newcommand{\ConstrSubCal}[3]{\ConstrSub{\mathcal{#1}}{#2}{#3}}

% Math Terminology
\newcommand{\Domain}[1]{\ConstrIt{domain}{#1}}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Thesis


\begin{document}

\author{Justin Pombrio}
\title{Resugaring: Restoring the Abstractions that Syntactic Sugar is Supposed to Provide}
\maketitle

\part{Syntactic Sugar}
\include{chapters/chapter01}
\include{chapters/chapter02}
\include{chapters/chapter03}






\chapter{Appendix}


% Expressions & Grammars
\newcommand{\lit}[1]{\textbf{#1}}
\newcommand{\expr}[2]{(#1\,#2)}
\newcommand{\var}[1]{\textrm{\textsc{#1}}}

% Grammars
\newcommand{\exprs}[3]{(#1\,#2\,#3^{*})}
\newcommand{\production}[2]{#1 \leftarrow #2}
\newcommand{\saysG}[3]{#1 \vdash #2\,:\,#3}


\subsection{Terms}

We will call \textsc{ast} terms \emph{expressions} and write them in
s-expression form. Atomic terms are either variables or literals
(i.e. syntactic constants), and compound terms are built with
\emph{term constructors} $P$:

\begin{Table}
  $e$
  &$::=$& $\lit{lit}$ &(literal) \\
  &$|$&   $\var{x}$ &(variable) \\
  &$|$&   $\expr{P}{e_1 ... e_n}$ &(\textsc{ast} node)
\end{Table}

\subsection{Tree Grammars}

A \emph{tree grammar} [CITE] is to trees as a context-free grammar is
to strings. Thus it can be viewed either as a set of instructions for
how to iteratively and nondeterministically rewrite a starting
\emph{nonterminal} to a final tree; \emph{or} it can be viewed as a
specification of a grammar that a tree may or may not follow. We will
take the latter view.

Definitionally, a tree grammar consists of a number of
\emph{productions} that map \emph{nonterminals} $s$ to
\emph{patterns}:
\begin{Table}
  $G$
  &$::=$& $\left\{ \begin{array}{l}
    \production{s_1}{\emph{pattern}_1} \\
    \ddd \\
    \production{s_n}{\emph{pattern}_n}
    \end{array}\right.$ \\
  \\
  $\emph{pattern}$
  &$::=$& $\expr{P}{s_1 \dd s_n}$ &(regular pattern) \\
  &$|$&
  $\exprs{P}{s_1 \dd s_n}{s_{n+1}}$
  &(ellipses pattern) \\
  &$|$&   $\emph{literal}$ &(matches literals) \\
  &$|$&   $\emph{var}$ &(matches variables)
\end{Table}

The \emph{meaning} of a tree grammar (again, we are viewing the
grammar as a \emph{specification}) is that for each production
``$\production{s}{\emph{pattern}}$'', if a term matches the
\emph{pattern}, then it also matches the nonterminal $s$. Formally:

\[
\fbox{$\saysG{G}{e}{s}$}
\]

\[
\inference
    [G-literal]
    {}
    {\saysG{G}{\lit{lit}}{\emph{literal}}}
\quad
\inference
    [G-variable]
    {}
    {\saysG{G}{\var{x}}{\emph{variable}}}
\]
    
\[
\inference
    [G-node]
    {\Forall{i \in 1..n} \saysG{G}{e_i}{s_i} \\
      \production{s}{\expr{P}{s_1 \dd s_n}} \in G}
    {\saysG{G}{\expr{P}{e_1 \dd e_n}}{s}}
\quad
\inference
    [G-ellipses]
    {\Forall{i \in 1..n} \saysG{G}{e_i}{s_i} \\
      \Forall{j \in 1..k} \saysG{G}{e_{n+j}}{s} \\
      \production{s}{\exprs{P}{s_1 \dd s_n}{s}} \in G}
    {\saysG{G}{\expr{P}{e_1 \dd e_n \dd e_{n+k}}}{s}}
\]

\end{document}
