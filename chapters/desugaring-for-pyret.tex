\chapter{Resugaring for Pyret}

\section{Example}

\subsection{Define-struct}

\paragraph{Core AST}
\begin{Codes}
Stmts:
| [\{splicing-begin stmts:Stmts\} @rest:Stmts]
   binding stmts in rest
   providing stmts, rest

| [\{let x:Var v:Expr\} @rest:Stmts]
   binding x in rest

| [\{fun f:Var args:Args body:Expr\} @rest:Stmts]
   binding args in body, rest in body
   providing f, rest

ALTERNATIVELY:

Stmts:
| \{splicing-begin stmts:Stmts rest:Stmts\}
   binding stmts in rest
   providing stmts, rest

| \{let x:Var v:Expr rest:Stmts\}
   binding x in rest

| \{fun f:Var args:Args body:Expr rest:Stmts\}
   binding args in body, rest in body
   providing f, rest

| \{end\}

Params:
| \{param x:Var rest:Params\}
| \{end\}
\end{Codes}

\paragraph{Auxiliary AST}
\begin{Codes}
IStructFields:
| [field:IStructField ...fields:IStructFields]
  providing field, fields

IStructField:
| \{i-struct-field field:Str get:Var set:Var\}
  providing get, set
\end{Codes}

\paragraph{Surface AST}
\begin{Codes}
SurfStmts:
  .....
| [(define-struct name:Var fields:StructFields) @rest:SurfStmts]
  binding name in rest, fields in rest
  providing name, fields, rest

StructFields:
| [field:StructField ...fields:StructFields]
  providing field, fields

StructField:
| (struct-field field:Str get:Var set:Var)
  providing get, set
\end{Codes}

\paragraph{Desugaring Rules}
\begin{Codes}
   [(struct-field field:Str get:Var set:Var) @rest:IStructFields]
=> [\{i-struct-field field get set\} @rest]
  
   [(define-struct name:Var
      [(struct-field field:Str get:Var set:Var) ...]) @rest:SurfStmts]
=> [\{fun name [x ...] \{record [\{record-field field x\} ...]\}\}
    \{splicing-begin [\{fun get [rec] \{record-get rec field\}\} ...]\}
    \{splicing-begin [\{fun set [rec val] \{record-set rec field val\}\} ...]\}
    @rest]
\end{Codes}

\subsection{Pyret For Expressions}

To handle Pyret for-expressions, we need to do two things.
First, when a for-expression binding (e.g. \Code{n from 0}) desugars,
it will simply return its binding (\Code{n}) and its value (\Code{0})
to the for-expression. It can do so with the desugaring rule:
\begin{Codes}
   (s-for-bind l:Loc b:Bind v:Expr)
=> \{for-bind b v\}
\end{Codes}
where \Code{ForBind} is a new type:
\begin{Codes}
  ForBind ::= \{for-bind Bind Expr\}

with list scope:
  [\{for-bind b v\} ...]
  export b
  export ...
\end{Codes}

Then for-expressions can be implemented with the desugaring rule:
\begin{Codes}
   (s-for l:Loc
          iter:Expr
          [\{ForBind bind:Bind value:Expr\} ...]@binds
          ann:Ann
          body:Expr
          blocky:Bool)
=> \{Lambda l (CONCAT "for-body<" (FORMAT l false) ">")
     [] [bind ...] ann "" body None None blocky\}
with scope:
  bind binds in body
\end{Codes}

Notice that \Code{s-for} is pattern matching against the results of
desugaring the \Code{s-for-bind}s. The \Code{(CONCAT ...)} stuff is to
compute at compile time a name for this lambda, which is what Pyret
currently does.

\section{Expressions}

\begin{Table}
core name $C$ &$::=$& \textit{name} & core syntactic construct name \\
surface name $m$ &$::=$& \textit{name} & surface syntactic construct name \\
expression $e$ &$::=$& $\Core{C}{e_1 ... e_n}$ & core syntactic construct \\
  &$|$& $\Surf{m}{e_1 ... e_n}$ & surface syntactic construct \\
  &$|$& $[e_1 ... e_n]$ & list \\
  &$|$& $string$ & string literal \\
  &$|$& $\Refn[i]{x}$ $|$ $\Decl[i]{x}$  & variable \\
value $v$ &$::=$& $e$ & with no sugar invocations \\
\end{Table}



\section{Expansion}

\begin{Table}
ellipsis label $l$ &$::=$& \textit{name} & ellipsis label \\
%shape $\dot{e}$ &$::=$& ...e... & (same cases as $e$) \\
%  &$|$& $\bullet$ & hole \\
pattern $p$ &$::=$& $\PVarA$ & pattern variable \\
  &$|$& $\Core{C}{p_1 ... p_n}$ & syntactic construct \\
  &$|$& $\Surf{m}{p_1 ... p_n}$ & sugar invocation \\
  &$|$& $[ps]$ & list \\
  &$|$& $string$ & string literal \\
  &$|$& $\Refn[i]{x}$ $|$ $\Decl[i]{x}$  & variable \\
seq. pattern $ps$ &$::=$& $\epsilon$ & empty sequence \\
  &$|$& $\Cons{p}{ps}$ & cons \\
  &$|$& $\Rep{p}{l}$ & ellipsis with label $l$ \\
fresh vars $F$ &$::=$& $\{x,...\}$ & fresh variable set \\
type env. $\Gamma$ &$::=$&
$\begin{cases}
  \PVarA:t, ... \\
  i \mapsto [\Gamma], ...
\end{cases}$ \\
substitution $\gamma$ &$::=$&
$\begin{cases}
  \PVarA \mapsto e, ... \\
  l \mapsto [\gamma ... \gamma], ... \\
  x \mapsto x, ...
\end{cases}$
\end{Table}

\begin{Table}
rewrite case $c$ &$::=$&
  $\DsRuleCase{(p_1,\,...,\,p_k)}{\Gamma}{F}{p'}$ \\
desugaring rule $r$ &$::=$&
  $\DsRule{m}{c_1,...,c_n}$ \\
desugaring rules $rs$ &$::=$& $\{r_1, ..., r_n\}$
\end{Table}

\subsection{Matching and Substitution}

\begin{figure}
\fbox{$\SaysMatch{F}{e}{p}{\gamma}$}
\begin{multicols}{2}
  \Inference[m-pvar]{}{
    \SaysMatch{F}{e}{\PVarA}{\{\PVarA \mapsto e\}}
  }

  \Inference[m-capture]{
    x \not\in F
  }{
    \SaysMatch{F}{x}{x}{\{\}}
  }

  \Inference[m-fresh]{
    x \in F
  }{
    \SaysMatch{F}{y}{x}{\{x \mapsto y\}}
  }

  \Inference[m-str]{}{
    \SaysMatch{F}{string}{string}{\{\}}
  }

  \Inference[m-empty]{}{
    \SaysMatch{F}{[\phantom{.}]}{\epsilon}{\{\}}
  }

  \Inference[m-cons]{
    \SaysMatch{F}{e_1}{p}{\gamma_1} \\
    \SaysMatch{F}{[e_2,...,e_n]}{ps}{\gamma_s} \\
    \gamma_1 \DisjUnion \gamma_2 = \gamma
  }{
    \SaysMatch{F}{[e_1 ... e_n]}{p,ps}{\gamma}
  }
\end{multicols}
\vspace{1em}

\Inference[m-con]{
  \SaysMatch{F}{e_1}{p_1}{\gamma_1} \;\cdots\; \SaysMatch{F}{e_n}{p_n}{\gamma_n}
  \gamma_1 \DisjUnion ... \DisjUnion \gamma_n = \gamma
}{
  \SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}{\gamma}
}

\Inference[m-star]{
  \SaysMatch{F}{e_1}{p}{\gamma_1} \;\cdots\; \SaysMatch{F}{e_n}{p}{\gamma_n}
}{
  \SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}{\{l \mapsto [\gamma_1 ... \gamma_n]\}}
}

\fbox{$\SaysSubs{F}{\gamma}{p}{e}$}
\begin{multicols}{2}
  \Inference[s-pvar]{
    \PVarA \mapsto e \in \gamma
  }{
    \SaysSubs{F}{\gamma}{\PVarA}{e}
  }

  \Inference[s-str]{}{
    \SaysSubs{F}{\gamma}{string}{string}
  }

  \Inference[s-capture]{
    x \not\in F
  }{
    \SaysSubs{F}{\gamma}{x}{x}
  }

  \Inference[s-fresh]{
    x \in F & x \mapsto y \in \gamma
  }{
    \SaysSubs{F}{\gamma}{x}{y}
  }

  \Inference[s-empty]{}{
    \SaysSubs{F}{\gamma}{[\epsilon]}{[\phantom{.}]}
  }

  \Inference[s-cons]{
    \SaysSubs{F}{\gamma}{p}{e_1} \\
    \SaysSubs{F}{\gamma}{[ps]}{[e_2,...,e_n]}
  }{
    \SaysSubs{F}{\gamma}{[p,ps]}{[e_1 e_2 ... e_n]}
  }
\end{multicols}
\vspace{1em}

\Inference[s-star]{
  l \mapsto [\gamma_1 ... \gamma_n] \in \gamma \\
  \SaysSubs{F}{\gamma_1}{p}{e_1} \;\cdots\; \SaysSubs{F}{\gamma_n}{p}{e_n}
}{
  \SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}
}

\Inference[s-con]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}
}

\Inference[s-sugar]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}
}

\caption{Matching and Substitution}
\end{figure}

\begin{lemma}[matching and substitution]
  Matching and substitution are inverses:
%  $\SaysSubs{F}{\gamma}{p}{e}$, then $\SaysMatch{F}{e}{p}{\gamma}$.
\end{lemma}
\begin{proof}
  Induct on $p$.
  [FILL]
\end{proof}
%However, the reverse is not true. Matching does not undo substitution,
%because substitution in non-deterministic (because it generates fresh
%variables).

\subsection{Expansion}

See \cref{fig:expansion}.
[TODO: Replace step with something that looks like desugaring.]
[TODO: Replace $v$ with something that looks like core terms.]

\begin{figure}
  \Inference[eval-ctx]{
    \SaysStep{L}{e}{e'}
  }{
    \SaysStep{L}{E[e]}{E[e']}
  }
  \Inference[eval-expand]{
    L = G,rs &
    \DsRule{m}{c_1 ... c_n} \in G \IS\\
    \SaysCase{L}{\Surf{m}{e_1 ... e_n}}{e''}{c_i} \IS\\
    \SaysNotCase{L}{\Surf{m}{e_1 ... e_n}}{e'}{c_j} \text{ for any } j<i
  }{
    \SaysStep{L}{\Surf{m}{e_1 ... e_n}}{e'}
  }
  \Inference[eval-case]{
    \SaysMatch{L}{e_i}{p_i}{\gamma_i} \text{ for each $i$} \IS \\
    \gamma' \text{ gives fresh names to the variables in $F$} \\
    \gamma_1 \DisjUnion ... \DisjUnion \gamma_n \DisjUnion \gamma' = \gamma \\
    \SaysSubs{F}{\gamma}{p'}{e'}
  }{
    \SaysCase{L}{\Surf{m}{e_1 ... e_n}}{e'}{(p_1,...,p_n);\Gamma;F \To p'}
  }
  \caption{Expansion}
  \label{fig:expansion}
\end{figure}

[FILL] One expansion rule. Note expansion contexts.



\section{AST Checking} % Or Syntype Checking

\begin{Table}
ast defn. $G$ &$::=$& $A \mapsto \{t_1, ... t_n\}$
  & (with no production $A_1 \mapsto A_2$) \\
syntactic category $A$ &$::=$& \textit{name} \\
syntax type $t$ &$::=$& $A$ & syntactic category \\
  &$|$& $\Core{C}{t_1 ... t_n}$ & syntactic construct \\
  &$|$& $[t]$ & list \\
  &$|$& String & string literal \\
  &$|$& Decl & variable declaration \\
  &$|$& Refn & variable reference \\
language $L$ &$::=$& $G, rs$
\end{Table}

Lemma: If rules grammar check, then e obeys Surf implies ds(e) obeys
Core.

Lemma: Normalizing a grammar does not change its language.

\paragraph{Exhaustion Checking}
We perform exhaustion checking to make sure that sugars cover all
possible cases of their arguments, but do not give the algorithm here.
It works by looking at \emph{shapes}: a shape is a pattern that
contains types in place of pattern variables. It is straightforward to
check whether an expression matches a shape, and to convert a pattern
into a shape. Exhaustion checking uses the fact that the expressions
that do \emph{not} match a shape can be expressed as a union of shapes.
[TODO: prove]

\begin{figure}

\fbox{$\SaysExpr{L}{e}{t}$}

\begin{multicols}{2}
  
  \Inference[e-con]{
    A \mapsto \Core{C}{t_1 ... t_n} \in L \\
    \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{L}{e_n}{t_n}
  }{
    \SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}
  }

  \Inference[e-refn]{}{
    \SaysExpr{L}{\Refn{x}}{\TRefn}
  }

  \Inference[e-decl]{}{
    \SaysExpr{L}{\Decl{x}}{\TDecl}
  }

  \Inference[e-str]{}{
    \SaysExpr{L}{\textit{string}}{\TString}
  }

  \Inference[e-list]{
    \SaysExpr{L}{e_1}{t} \;\cdots\; \SaysExpr{L}{e_n}{t}
  }{
    \SaysExpr{L}{[e_1 ... e_n]}{[t]}
  }

  \Inference[e-sugar]{
    \SaysRule{L}{m}{t_1,...,t_n}{t} \\
    \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{L}{e_n}{t_n}
  }{
    \SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}
  }
\end{multicols}

\fbox{$\SaysPatt{L}{\Gamma}{p}{t}$}

\begin{multicols}{2}

  \Inference[p-pvar]{
    \PVarA : t \in \Gamma
  }{
    \SaysPatt{L}{\Gamma}{\PVarA}{t}
  }

  \Inference[p-refn]{}{
    \SaysPatt{L}{\Gamma}{x}{\TRefn}
  }

  \Inference[p-decl]{}{
    \SaysPatt{L}{\Gamma}{x}{\TDecl}
  }

  \Inference[p-str]{}{
    \SaysPatt{L}{\Gamma}{\textit{string}}{\TString}
  }

  \Inference[p-con]{
    A \mapsto \Core{C}{t_1 ... t_n} \in L \\
    \SaysPatt{L}{\Gamma}{p_1}{t_1} \;\cdots\; \SaysPatt{L}{\Gamma}{p_n}{t_n}
  }{
    \SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}
  }

  \Inference[p-sugar]{
    \SaysRule{L}{m}{t_1,...,t_n}{t} \\
    \SaysPatt{L}{\Gamma}{p_1}{t_1} \;\cdots\; \SaysPatt{L}{\Gamma}{p_n}{t_n}
  }{
    \SaysPatt{L}{\Gamma}{\Surf{m}{p_1 ... p_n}}{t}
  }

  \Inference[p-empty]{}{
    \SaysPatt{L}{\Gamma}{[\epsilon]}[t]
  }

  \Inference[p-cons]{
    \SaysPatt{L}{\Gamma}{p}{t} \\
    \SaysPatt{L}{\Gamma}{[ps]}{[t]}
  }{
    \SaysPatt{L}{\Gamma}{[\Cons{p}{ps}]}{[t]}
  }

  \Inference[p-star]{
    l \mapsto [\Gamma'] \in \Gamma & \SaysPatt{L}{\Gamma'}{p}{t}
  }{
    \SaysPatt{L}{\Gamma}{[\Rep{p}{l}]}{[t]}
  }
\end{multicols}

\fbox{$\SaysRule{L}{m}{t,...,t}{t}$}
\Inference[g-sugar]{
  \DsRuleFancy
      {m}
      {(p_{11},...,p_{1n});\Gamma_1;F_1 \To p_1'}
      {(p_{k1},...,p_{kn});\Gamma_k;F_k \To p_k'}
      \in L \\
  \text{The cases are exhaustive over $t_1,...,t_n$ in $G$} \\
  \SaysPatt{L}{\Gamma_{i}}{p_{ij}}{t_j}
    \text{ for each $i \in 1..k, j \in 1..n$} \\
  \SaysPatt{L}{\Gamma_{i}}{p_i'}{t}
    \text{ for each $i \in 1..k$}
}{
  \SaysRule{L}{m}{t_1,...,t_n}{t}
}

\fbox{$\SaysEnv{L}{\gamma}{\Gamma}$}
\Inference[$\gamma$-env]{
  \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{e_n}{t_n} \\
  \SaysEnv{L}{\gamma_{11}}{\Gamma_1} \;\cdots\; \SaysEnv{L}{\gamma_{1j}}{\Gamma_1} \\
  ... \\
  \SaysEnv{L}{\gamma_{m1}}{\Gamma_m} \;\cdots\; \SaysEnv{L}{\gamma_{mk}}{\Gamma_m} \\
}{
  \SaysEnv{L}{
    \begin{cases}
      \PVarA_1 \mapsto e_1,\,...,\,\PVarA_n \mapsto e_n \\
      i_1 \mapsto [\gamma_{11},\,...,\,\gamma_{1j}] \\
      ... \\
      i_m \mapsto [\gamma_{m1},\,...,\,\gamma_{mk}]
    \end{cases}
  }{
    \Gamma',
    \begin{cases}
      \PVarA_1: t_1,\,...,\,\PVarA_n: t_n, \\
      %\PVarA_1': t_1',\,...,\,\PVarA_{n'}': t_{n'}' \\
      i_1 \mapsto [\Gamma_1],\,...,\,i_m \mapsto [\Gamma_m], \\
      %i_1' \mapsto [\Gamma_1'],\,...,\,i_{m'}' \mapsto [\Gamma_{m'}']
    \end{cases}
  }
}

\caption{Grammar Checking}
\end{figure}

\subsection{Type Soundness}

We prove soundness by way of progress + preservation:
\begin{theorem}[Soundness]
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysSteps{L}{e}{v}$ where $\SaysExpr{L}{v}{t}$, or $e$ runs forever.
\end{theorem}
\begin{proof}
\Cref{thm:progress} (progress) and \cref{thm:preservation}
(preservation) together imply that either:
(i) $e$ is a value, or (ii) $\SaysStep{L}{e}{e'}$ and $\SaysExpr{L}{e'}{t}$.
Apply this repeatedly. Either $e$ eventually steps to a value $v$, and
has remained the same type $t$ throughout the evaluation, or $e$ never
halts.
\end{proof}

\begin{lemma}[Progress] \label{thm:progress}
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysStep{L}{e}{e'}$, or $e$ is a value.
\end{lemma}
\begin{proof}
  First, verify that our evaluation contexts include every case that
  isn't a value. Thus either $e$ is a value and we are done, or $e$
  contains a redex: $e=E[\Surf{m}{e_1 ... e_n}]$.
  In the latter case, we will show that $e$ can take a step because
  the eval-expand rule applies. There are two premises that need to be
  satisfied:
  \begin{itemize}
    \item First, we must show that $m$ is bound in $L$. Since $e$
      type-checked, it must be: the only rule which can type-check a
      sugar invocation is p-sugar; this in turn must use rule
      g-sugar; finally g-sugar requires that $m \in L$.
    \item Second, we must show that the pattern match of $e_1,...,e_n$
      succeeds on any case $(p_1,...,p_n);\Gamma;F$ of the desugaring
      rule. By \cref{thm:exhaustion}, it does.
  \end{itemize}
\end{proof}

\begin{assumption}[Exhaustion] \label{thm:exhaustion}
  If the set of cases in a desugaring rule are exhaustive over
  $t_1,...,t_n$ according to our exhaustion checking algorithm, then
  for every possible argument list $e_1,...,e_n$ that matches the
  given types (i.e., $\SaysExpr{L}{e_1}{t_1},...,\SaysExpr{L}{e_n}{t_n}$),
  there is a case $c_i$ such that $e_1,...,e_n$ successfully matches
  against $c_i$. [TODO: prove]
\end{assumption}
\begin{proof}
  \emph{Not given}. We have not stated our exhaustion checking
  algorithm here, and so cannot prove it correct. We believe it is
  straightforward (if tedious).
\end{proof}

\begin{lemma}[Preservation] \label{thm:preservation}
  If $\SaysExpr{L}{e}{t}$ and $\SaysStep{L}{e}{e'}$, then $\SaysExpr{L}{e'}{t}$.
\end{lemma}
\begin{proof}
  Since $e$ can take an expansion step, it must have a redex (via
  eval-ctx): $e = E[\Surf{m}{e_1 ... e_n}]$. And furthermore (by eval-expand) $m$
  must be bound in $L$, and there must be a first case of $m$ that
  matches $e$.  Call it $c_i = (p_1,...,p_n);\Gamma \To p'$. Then:
  \begin{ProofTable}
  By eval-case: & $\SaysMatch{L}{e_i}{p_i}{\gamma_i}$
    for some $\gamma_i$ for each $i$ & (1) \\
  and & $\SaysSubs{F}{\gamma_i \DisjUnion ...
    \DisjUnion \gamma_n}{p'}{e'}$ & (2) \\
  and & $\SaysStep{L}{E[e]}{E[e']}$ \\
  By e-sugar: & $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$ \\
  and & $\SaysRule{L}{m}{t_1 ... t_n}{t}$ \\
  and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
  By g-sugar: & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (4) \\
  and & $\SaysPatt{L}{\Gamma}{p'}{t}$ & (5)
  \end{ProofTable}
  By \cref{thm:matching} with (1), (3), and (4),
  $\SaysEnv{\gamma_i}{\Gamma}$ for each $i$. By \cref{thm:union},
  $\SaysEnv{\gamma_1 \DisjUnion ... \gamma_n}{\Gamma}$.
  Finally, by \cref{thm:substitution} with that last fact together
  with (2) and (5), $\SaysExpr{L}{e'}{t}$.
\end{proof}

\begin{lemma}[Union of Substitutions] \label{thm:union}
  If $\SaysEnv{L}{\gamma_1}{\Gamma}$ and $\SaysEnv{L}{\gamma_2}{\Gamma}$,
  then $\SaysEnv{L}{\gamma_1 \DisjUnion \gamma_2}{\Gamma}$.
\end{lemma}
\begin{proof}
  [TODO]
\end{proof}

\begin{lemma}[Matching] \label{thm:matching}
  If $\SaysPatt{L}{\Gamma}{p}{t}$
  and $\SaysExpr{L}{e}{t}$
  and $\SaysMatch{F}{e}{p}{\gamma}$,
  then $\SaysEnv{L}{\gamma}{\Gamma}$
\end{lemma}
\begin{proof}
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
    \begin{ProofTable}
      By p-str: & $\SaysPatt{L}{\Gamma}{string}{\TString}$ & fixes $t$ \\
      By m-str: & $\SaysMatch{F}{string}{\TString}{\EmptySubs}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, by $\gamma$-env, $\SaysEnv{F}{\EmptySubs}{\Gamma}$
    (this applies for any $\Gamma$).
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By p-refn or p-decl, 
    $\Gamma = \{\}$ and $t$ is {\TRefn} or {\TDecl}.
    By m-fresh, $e = y$ for some fresh name $y$, and $\gamma = \{\}$.
    And the conclusion follows: $\SaysEnv{L}{\{\}}{\{\}}$. [TODO]
  \item[$p = \PVarA$]
    \begin{ProofTable}
      By p-pvar: & $\SaysPatt{L}{\Gamma}{\PVarA}{t}$ & fixes $t$ \\
      and & $\PVarA: t \in \Gamma$ & (1) \\
      By m-pvar: & $\SaysMatch{F}{e}{\alpha}{\{\PVarA \mapsto e\}}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, using $\gamma$-env on the premise $\SaysExpr{L}{e}{t}$
    gives that $\SaysEnv{L}{\gamma}{\{\PVarA: t\}},\Gamma'$ for any
    $\Gamma'$. By (1), this is the form of $\Gamma$, so we can set
    $\Gamma'$ such that $\Gamma = {\{\PVarA: t\}},\Gamma'$, and we are done.
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-con: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (1) \\
      By m-con: &
        $\SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}{\gamma}$
        & fixes $e$ \\
      and & $\SaysMatch{F}{e_i}{p_i}{\gamma_i}$ for each $i$ & (2) \\
      and & $\gamma = \gamma_1 \DisjUnion ... \DisjUnion \gamma_n$ \\
      By e-con: & $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
    \end{ProofTable}
    Applying the I.H. to (1), (2), and (3) yeilds that
    $\SaysEnv{L}{\gamma_i}{\Gamma}$.
    By \cref{thm:union}, $\SaysEnv{L}{\gamma}{\Gamma}$.
  \item[$p = \Surf{m}{p_1 ... p_n}$] [FILL]
  \item[$p = [\epsilon{]}$] [TODO] By m-empty, $\gamma = \{\}$.
    By p-empty, $\Gamma = \{\}$. The goal follows: $\SaysEnv{L}{\{\}}{\{\}}$.
  \item[$p = [p,ps{]}$] [FILL]
  \item[$p = [\Rep{p}{l'}{]}$]
    \begin{ProofTable}
      By p-star: & $\SaysPatt{L}{\Gamma}{\Rep{p}{l'}}{[t]}$ & fixes $t$ \\
      and & $l' \mapsto [\Gamma'] \in \Gamma$ & (1) \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (2) \\
      By m-star: & $\SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}
        {\{l' \mapsto [\gamma_1 \DisjUnion ... \gamma_n]\}}$
        & fixes $e$, $\gamma$ \\
      and & $\SaysMatch{F}{e_i}{p}{\gamma_i}$ for each $i$ & (3) \\
      By e-list: & $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ & (4)
    \end{ProofTable}
    By the I.H. together with (2), (3), and (4),
    $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$.
    By \cref{thm:union},
    $\SaysEnv{L}{\gamma_1 \DisjUnion ... \gamma_n}{\Gamma'}$.
    Finally, by $\gamma$-env,
    $\SaysEnv{L}{\{l' \mapsto [\gamma_1 \DisjUnion ... \gamma_n]\}}
      {\{l' \mapsto [\Gamma']\}}$, which is compatible with the
      specification of $\Gamma$ in (1).
  \end{description}
\end{proof}

\begin{lemma}[Substitition] \label{thm:substitution}
  If $\SaysEnv{L}{\gamma}{\Gamma}$
  and $\SaysPatt{L}{\Gamma}{p}{t}$,
  and $\SaysSubs{F}{\gamma}{p}{e}$,
  then $\SaysExpr{L}{e}{t}$.
\end{lemma}
\begin{proof}
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
  \item[$p = string$] By s-str, $\SaysSubs{F}{\gamma}{p}{string}$, so $e=string$.
    By p-str, $\SaysPatt{L}{\Gamma}{p}{\TString}$, so $t=\TString$.
    Finally, by e-str, $\SaysExpr{L}{e}{\TString}$ as desired.
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By s-fresh, $e = y$ for some fresh name $y$.
    By p-refn or p-decl, $t$ is either {\TRefn} or {\TDecl}.
    Our goal $\SaysExpr{L}{y}{t}$ follows by either e-refn or e-decl,
    respectively.
  \item[$p = \PVarA$] By rule s-pvar, $\PVarA \mapsto e \in \gamma$.
    By $\gamma$-env, $\alpha \mapsto t \in \Gamma$ and $\SaysExpr{L}{e}{t}$.
    Which is our goal; we are done.
    (Note that by $\gamma$-env, $\Gamma$ may have many \emph{other},
    unnecessary, bindings to pattern variables, but it must \emph{at least}
    contain a correct binding for $\alpha$.)
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-con: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ & (1) \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      By s-con: & $\SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (3)
    \end{ProofTable}
    Using the I.H. with (2) and (3) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Using e-con on that fact together with (1) gives that
    $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$, so we are done.
  \item[$p = \Surf{m}{p_1 ... p_n}$]
    \begin{ProofTable}
      By s-sugar: & $\SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (1) \\
      By p-sugar: & $\SaysPatt{L}{\Gamma}{\Surf{m}{p_1 ... p_n}}{t}$
        & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      and & $\SaysRule{L}{m}{t_1,...,t_n}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1) and (2) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Finally, using e-sugar on that fact together with (3) gives that
    $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$.
  \item[$p = [\epsilon{]}$]
    By s-empty, $\SaysSubs{F}{\gamma}{p}{[]}$, so $e=[]$.
    By p-empty, $\SaysPatt{L}{\EmptyEnv}{[\epsilon]}{[t]}$ (for some $t$).
    Finally, by e-list, $\SaysExpr{L}{[]}{[t]}$.
  \item[$p = [p,ps{]}$]
    \begin{ProofTable}
      By s-cons: & $\SaysSubs{F}{\gamma}{p}{e_1}$ & (1) \\
      and & $\SaysSubs{F}{\gamma}{[ps]}{[e_2 ... e_n]}$ & (2) \\
      and & $\SaysSubs{F}{\gamma}{[p, ps]}{[e_1 e_2 ... e_n]}$ & fixes $e$ \\
      By p-cons: & $\SaysPatt{L}{\Gamma}{p}{t}$ & (3) \\
      and & $\SaysPatt{L}{\Gamma}{[ps]}{[t]}$ & (4) \\
      and & $\SaysPatt{L}{\Gamma}{[p, ps]}{[t]}$ & fixes $t$
    \end{ProofTable}
    We can apply the I.H. using (1) and (3) and the assumption
    $\SaysEnv{L}{\gamma}{\Gamma}$ to get that $\SaysExpr{L}{e_1}{t}$.
    Likewise, the I.H. with (2) and (4) gives
    $\SaysExpr{L}{[e_2 ... e_n]}{[t]}$.
    By e-list (in reverse), $\SaysExpr{L}{e_2}{t} \cdots \SaysExpr{L}{e_n}{t}$.
    Finally, by e-list (forward), $\SaysExpr{L}{[e_1 e_2 ... e_n]}{[t]}$.
  \item[$p = [\Rep{p}{l}{]}$]
    \begin{ProofTable}
      By s-star: & $\SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}$ & fixes $e$ \\
      and & $l \mapsto [\gamma_1 ... \gamma_n] \in \gamma$ \\
      and & $\SaysSubs{F}{\gamma_i}{p}{e_i}$ for each $i$ & (1) \\
      By $\gamma$-env: & $l \mapsto [\Gamma'] \in \Gamma$ \\
      and & $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$ & (2) \\
      By p-star: & $\SaysPatt{L}{\Gamma}{[\Rep{p}{l}]}{[t]}$ & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1), (2), and (3) proves that
    $\SaysExpr{L}{e_i}{t}$.
    Then, by e-list, $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ as desired.
  \end{description}
\end{proof}

\section{Scope Checking}

(See \cref{fig:scope}.)

\begin{figure}
\fbox{$\SaysScope{\Sigma}{e}
  {\{\Decl{x}\}}
  {\{\Refn{x}\}}
  {\{\Decl{x}\}}
  {\{\Refn{x}\mapsto\Decl{x}\}}$}

\Inference[scope-e-decl]{}{
  \SaysScope{\Sigma}{\Decl{x}}{\{\Decl{x}\}}{\{\}}{\{\Decl{x}\}}{\{\}}
}

\Inference[scope-e-refn]{}{
  \SaysScope{\Sigma}{\Refn{x}}{\{\}}{\{\Refn{x}\}}{\{\}}{\{\}}
}

\Inference[scope-e-con]{
  \Sigma[C] = \sigma \vspace{0.1em} \IS\\
  \SaysScope{\Sigma}{e_i}{P_i}{R_i}{B_i} \text{ for } i \in 1..n \IS\\
  S = \SetSuchThat{
    \Decl[a]{x} \mapsto \Decl[b]{x}
  }{
    \Decl[a]{x} \in P_i,\;
    \Decl[b]{x} \in P_j,\;
    \Bind{\sigma}{i}{j}
  } \IS\\
  B = \SetSuchThat{
    \Refn[a]{x} \mapsto \Decl[b]{x}
  }{
    \Refn[a]{x} \in R_i,\;
    \Decl[b]{x} \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    \Decl[b]{x} \not\in \Domain{S}
  } \IS\\
  R = \SetSuchThat{
    \Refn[a]{x}
  }{
    \Refn[a]{x} \in R_i,\;
    \NotExists{\Decl[b]{x}}{\Refn[a]{x} \mapsto \Decl[b]{x} \in B\}}
  } \IS\\
  P = \SetSuchThat{
    \Decl[a]{x}
  }{
    \Decl[a]{x} \in P_i,\;
    \Prov{\sigma}{i},\;
    \Decl[a]{x} \not\in \Domain{S}
  }
}{
  \SaysScope{\Sigma}{\Core{C}{e_1 ... e_n}}{P}{R}{B}
}


\Inference[scope-p-con]{
  \Sigma[C] = \sigma \vspace{0.1em} \IS\\
  \SaysScope{\Sigma}{p_i}{P_i}{R_i}{B_i} \text{ for } i \in 1..n \IS\\
  S = \SetSuchThat{
    a \mapsto b
  }{
    a \in P_i,\;
    b \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    \SaysCanShadow{F}{a}{b}
  } \IS\\
  B = \SetSuchThat{
    a \mapsto b
  }{
    a \in R_i,\;
    b \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    b \not\in \Domain{S},\;
    \SaysCanBind{F}{a}{b}
  } \IS\\
  R = \SetSuchThat{
    a
  }{
    a \in R_i,\;
    (\NotExists{b}{a \mapsto b \in B\}}
    \text{ or $a$ is a pattern var})
  } \IS\\
  P = \SetSuchThat{
    a
  }{
    a \in P_i,\;
    \Prov{\sigma}{i},\;
    a \not\in \Domain{S}
  }
}{
  \SaysScope{\Sigma}{\Core{C}{p_1 ... p_n}}{P}{R}{B}
}

Two checks to make: fresh vars don't bind to non-fresh vars, and named
vars only bind to vars of the same name:
\begin{multicols}{3}
  \Inference{}{
    \SaysCanBind{F}{\Refn[1]{x}}{\Decl[2]{x}}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanBind{F}{\Refn[1]{x}}{\PVarA}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanBind{F}{\PVarA}{\Decl[1]{x}}
  }
  \Inference{}{
    \SaysCanBind{F}{\PVarA}{\PVarB}
  }
  \Inference{}{
    \SaysCanShadow{F}{\Decl[1]{x}}{\Decl[2]{x}}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanShadow{F}{\Decl[1]{x}}{\PVarA}
  }
\end{multicols}

\caption{Scope Checking Rules}
\label{fig:scope}
\end{figure}
