\newcommand{\Resugarer}{\Sc{Tobenamed}}

\chapter{Resugaring Evaluation Sequences}\label{chap:resugar-eval}

In this chapter, we tackle the challenge of combining syntactic sugar
with semantics[CITE, CITE]. Given a set of desugaring rules, of the
form shown in [REF], we show how to \emph{resugar program execution}:
to \emph{automatically} convert an evaluation sequence in the core
language into a representative evaluation sequence in the surface
syntax. Each step in the surface language emulates one or more steps
in the core language. The computed steps hide the transformation, thus
maintaining the abstraction provided by the surface language.

The chief challenge is to remain faithful to the original
semantics---we can't change the meaning of a program!---and to ensure
that the internals of the code introduced by the syntactic sugar does
not leak into the output. Our chief mechanisms for achieving this are
to (i) perform static checks on the desugaring definitions to ensure
they fall into the subset we can handle [TODO], and (ii) rewrite the
reduction relation with instrumentation to track the origin of terms.
These ideas are implemented in \Tool [LINK] (see also our prototypes from
prior publications [LINK, LINK]), and we formally verify key properties
of our approach, given simplifying assumptions, in the Coq proof
assistant.


\section{Our Approach}

We aim to compute sensible evaluation sequences in a surface language,
while remaining faithful to the core language's semantics.  One approach
would be to attempt to construct a lifted (to the surface language)
reduction-relation directly. It is unclear, however, how to do this
without making deep assumptions about the core language evaluator
(for instance, assuming that it is defined as a term-rewriting system that can be composed
with desugaring).

Our approach instead makes minimal assumptions about the
evaluator, treating it as a black-box (since it is often a complex
program that we may not be able to modify).
We assume only that we have access to a \emph{stepper} that
provides a sequence of evaluation steps (augmented with some
meta information) in the \emph{core} language. In 
\cref{sec:reval-lang} we show how to obtain such a stepper from a generic,
black-box
evaluator with a strategy that can be implemented by pre-processing
the program before evaluation.

Our high-level approach is to follow the evaluation steps in the core
language, find surface-level representations of some of the core
terms, and emit them. Not every core-level term will have a
surface-level representation; these steps will be skipped in the
output. The evaluation sequence shown, then, is the sequence of
surface-level representations of the core terms that were not
skipped. Central to this approach are three properties:

\begin{description}
\item[Emulation] Each term in the generated surface evaluation
  sequence desugars into the core term which it is meant to represent
  (up to term isomorphism).
\item[Abstraction] Code introduced by desugaring is never revealed in the
  surface evaluation sequence, and code originating from the original
  input program is never hidden by resugaring.
\item[Coverage] Resugaring is attempted on every core step, and as few
  core steps are skipped as possible.
\item[Hygiene] [FILL]
\end{description}
[TODO: preview more precise definitions?]

\section{Informal Solution Overview}
\label{sec:reval-exposition}

We first present the techniques used by our solution, and some subtleties,
informally. We choose a familiar desugaring example: the rewriting
of \Code{Or}, as used in languages like Lisp and Scheme. We assume
the surface language has \Code{Or} as a construct, while the core does
not. We present our examples using a traditional infix concrete syntax.

% Unexpansion
\subsection{Finding Surface Representations Preserving Emulation}

We start by defining a simple, binary version of \Code{Or} (that
let-binds its first argument in case it has side-effects):
\begin{Codes}
Or(x, y) -> Let([Binding("t", x)],
                If(Id("t"), Id("t"), y)));
\end{Codes}
[TODO: Update example and remove this paragraph]
This is the actual transformation syntax processed by [TODO]
inspired by that of Stratego~\cite{stratego}.
Nodes' names are written in title-case and their subnodes follow in parentheses,
lists are surrounded by square brackets, and variables are written in
lowercase. We call the whole production a \emph{transformation rule}, or
\emph{rule} for short; the
part to the left of the arrow is its
\emph{\Sc{lhs}} (left-hand-side), and the part after the arrow its
\emph{\Sc{rhs}}.
When the \Sc{lhs} of a rule matches a term, this induces
bindings for the variables in the \Sc{lhs}, which are then substituted
in the \Sc{rhs}. The full definition of transformations is given
in \cref{sec:reval-transformations}.
In this section we focus on abstract syntax and ignore
the mapping to it from concrete syntax.

Consider the surface term \Code{not(true) OR not(false)}. After
desugaring, this would evaluate as follows in the core language
(assuming a typical call-by-value evaluator):
\begin{Codes}
    let t = not(true) in
      if t then t else not(false)
\CoreStep let t = false in
      if t then t else not(false)
\CoreStep if false then false else not(false)
\CoreStep not(false)
\CoreStep true
\end{Codes}
In the surface language, we would wish to see this as (using dashed
arrows to denote reconstructed steps):
\begin{Codes}
    not(true) OR not(false)
\SurfStep false OR not(false)
\SurfStep not(false)
\SurfStep true
\end{Codes}
The first two terms in the core evaluation sequence are precisely the
expansions of the first two steps in the (hypothetical) surface evaluation
sequence. This suggests
we can \emph{unexpand} core terms into surface terms by running rules ``in
reverse'': matching against the \Sc{rhs} and substituting into the
corresponding \Sc{lhs}.
(To preserve emulation, unexpansion must be an inverse of expansion: we
prove that this is so in \cref{sec:reval-inverses}.)
We will now show how the last two steps
may come about.

\subsection{Maintaining Abstraction}
\label{sec:reval-exposition-tagging}

When unexpanding, we should only unexpand code that
originated from a transformation. If the surface program itself is
\begin{Codes}
let t = not(true) in
  if t then t else not(false)
\end{Codes}
it should not unexpand into \Code{not(true) OR not(false)}:
this would be confusing and break the second clause of the Abstraction property.

We therefore augment each subterm in a core term
with a list of \emph{tags}, which indicate whether a term
originated in the original source or from the transformation.%
\footnote{Whereas the tags used in hygienic macro
  expansion~\cite{hygienic-macros} specify time steps,
  the tags in resugaring specify which sugar the
  code originated from.}
Unexpansion attempts to process terms marked as
originating from a transformation rule; this
unexpansion will fail if the tagged term no longer has the form of
the rule's \Sc{rhs}. When that happens, we conclude that there is no
surface representation of the core term and skip the step.

To illustrate this, we revisit the same core evaluation sequence as
before. Compound terms that originated from the source are underlined, and
``\Code{Or: }'' is a tag on the desugared expression that indicate it
originated from the \Code{Or} sugar:
\begin{Codes}
    \{Or: let t = \underline{not(true)} in
      if t then t else \underline{not(false)}\}
\CoreStep \{Or: let t = false in
      if t then t else \underline{not(false)}\}
\CoreStep \{Or: if false then false else \underline{not(false)}\}
\CoreStep \underline{not(false)}
\CoreStep true
\end{Codes}
The tags on the first three steps suggest that \Code{Or}'s transformation
rule be applied in reverse. The first two steps can be unexpanded because
they match the \Sc{rhs} of \Code{Or}, whereas the third
does not match the \Sc{rhs} and is therefore skipped,
yielding no surface step.  The last two steps are not tagged and are
therefore included in the surface evaluation sequence as-is.

\subsection{Striving for Coverage}

Emulation and Abstraction guarantee an accurate
surface evaluation sequence, but they do not guarantee a useful one. For
instance, the following evaluation sequence is perfectly consistent with
these two properties:
\begin{Codes}
    not(true) OR not(false)
\SurfStep true
\end{Codes}
However, a stepper that only shows the final step is unhelpful. We therefore
propose a third property, Coverage, which states that steps
are not ``unnecessarily'' skipped. While Emulation and
Abstraction are formally proved in \cref{sec:reval-proofs}, we have not found a
formalization of Coverage, so we can only strive to attain it in
our systems and evaluate it in practice. Our examples
(\cref{sec:reval-pyret-example} and \cref{sec:reval-examples}) show
that we do indeed obtain detailed and useful surface evaluation sequences.


\subsection{Trading Abstraction for Coverage}
\label{sec:reval-trading}

[TODO: add to Pyret implementation]

Suppose the surface term \Code{A OR B OR C} parses to
\Code{Or(A, B, C)}. We therefore want to extend \Code{Or}
to handle more than two sub-terms.  We can do this by adding another
rule:
\begin{Codes}
Or([x, y]) ->
  Let([Binding("t", x)],
      If(Id("t"), Id("t"), y)));
Or([x, y, ys ...] ->
  Let([Binding("t", x)],
      If(Id("t"), Id("t"), Or([y, ys ...])));
\end{Codes}
We assume a prioritized semantics in which rules are tried in
order; the first rule whose \Sc{lhs} matches the invocation is
used. The ellipses denote zero or more repetitions
of the preceding pattern~\cite{macro-by-example}.

Consider the surface term \Code{(false OR false OR true)}. 
Given the revised definition of \Code{Or}, unexpansion would yield the
following lifted evaluation steps:
\begin{Codes}
    false OR false OR true
\SurfStep true
\end{Codes}
In particular, it correctly suppresses any presentation of the recursive
invocation of \Code{Or}
introduced by the transformation---precisely what Abstraction demands!
However, there are settings
(such as debugging or education) where the user might wish to see this
invocation, i.e., to obtain the surface evaluation sequence
\begin{Codes}
    false OR false OR true
\SurfStep false OR true
\SurfStep true
\end{Codes}
Thus, we let sugar authors make part of a rule's \Sc{rhs}
visible by prefixing it with \Code{!}. Here, writing the second
\Code{Or} rule as
\begin{Codes}
Let([Binding("t", x)],
    If(Id("t"), Id("t"), !Or([y, ys ...])))
\end{Codes}
yields the latter surface evaluation sequence.

This illustrates that there is a trade-off (which we make precise with
\cref{thm:reval-abstraction}) between Abstraction and Coverage.
Because the trade-off depends on
goals, we entrust it to the sugar author.  In the limit,
marking the entirety of each rule as transparent results in
an ordinary trace in the core, ignoring all sugar.


\section{{\Resugarer} at Work}
\label{sec:reval-pyret-example}

[TODO: Update example for new resugarer]

We demonstrate how the techniques just described come together to show
surface evaluation sequences in the presence of sugar. Consider the
following program, written in the language Pyret (\url{pyret.org}), 
that computes the length of a list:
\begin{Codes}
    fun len(x):
      cases(List) x:
        | empty() => 0
        | link(_, tail) => len(tail) + 1
      end
    end
    len([1, 2])
\end{Codes}
This seemingly innocuous program contains a lot of sugar. The \Code{cases}
expression desugars into an application of the matchee's \Code{\_match}
method on an object containing code for each branch; the function
declaration desugars into a let binding to a lambda; addition desugars
into an application of a \Code{\_plus} method; and the list \Code{[1, 2]}
desugars into a chain of list constructors. Here is the full desugaring
(i.e., the code that will actually be run):
\begin{Codes}
len = fun(x):
    temp17 :: List = x
    temp17.["_match"](
      \{"empty" : fun(): 0 end,
       "link" : fun(_, tail):
                len(tail).["_plus"](1) end\},
      fun(): raise("cases: no cases matched");)
    end
len(list.["link"](1, list.["link"](2, list.["empty"])))
\end{Codes}
This degree and nature of expansion is not unique to Pyret.
It is also found in languages like Scheme, due
to the small size of the core, and in semantics like
$\lambda_{JS}$~\cite{lambda-js},
due to both the size of the core and the enormous complexity
of the surface language.

Nevertheless, here is the surface evaluation (pretty-)printed by {\Resugarer} (where
\Code{<func>} denotes a resolved functional):
\begin{Codes}
\SurfStep <func>([1, 2])
\SurfStep cases(List) [1, 2]:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end
\SurfStep <func>([2]) + 1
\SurfStep (cases(List) [2]:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end) + 1
\SurfStep <func>([]) + 1 + 1
\SurfStep (cases(List) []:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end) + 1 + 1
\SurfStep 0 + 1 + 1
\SurfStep 1 + 1
\SurfStep 2
\end{Codes}
This sequence hides all the complexity of the core language.

\section{The Transformation System}
\label{sec:reval-transformations}

We will present evaluation resugaring in three parts. First
(\cref{sec:reval-onerule}), we will describe how our transformation system
works, up to the level of performing a single transformation. Next
(\cref{sec:reval-manyrule}), we will describe how to use tags to fully
desugar and resugar terms, transforming not just a term but its subterms
as well. Finally (\cref{sec:reval-lifting}), we will show how to use the
transformation system to lift core evaluation sequences to surface
evaluation sequences.





\newpage
\section{SCRATCH}

Extend terms:
\begin{Table}
  $e$ &$::=$& ... \\
  &$|$& $\Tag{p}{p}{e}$ & tagged term
\end{Table}

If a term is shown in the reconstructed surface evaluation sequence, then
each non-atomic part of it originated from the original program and
has honest tags. (Assuming that evaluation does not modify tags.)

%If $\Desugar{C} \stepsCore \Desugar{C'}$,
%then $\forall E,t_1,...,t_k$,
%$E[C[t_1,...,t_k]] \stepsSurf E[C'[t_1,...,t_k]]$



\begin{figure}
  NOTES: Surface terms are any untagged terms.
  \begin{Table}
    $s$ &$::=$& $\Value$ \\
    &$|$& $\Refn{x}$ \\
    &$|$& $\Decl{x}$ \\
    &$|$& $\Surf{C}{s \dd}$ \\
    &$|$& $[s \dd]$ \\
    \\
    $E_{rs}$ &$::=$& $\square$ \\
    &$|$& $\Core{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Surf{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Aux{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Tag{p}{p}{E_{rs}}$ \\
    &$|$& $[s \dd E_{rs}\,e \dd]$
  \end{Table}

  \begin{multicols}{2}

  \TypeLabel{\SaysResugar{L}{c}{s}}

  \Inference[resugar]{
    \SaysRss{L}{c}{s}
  }{
    \SaysResugar{L}{c}{s}
  }
  
  \TypeLabel{\SaysRs{L}{e}{e}}
  
  \Inference[rs-ctx]{
    \SaysUnexp{L}{e}{e'}
  }{
    \SaysRs{L}{E_{rs}[e]}{E_{rs}[e']}
  }

  \end{multicols}

  \TypeLabel{\SaysUnexp{L}{e}{e}}

  \Inference[unexp-tag]{
    e \text{ has no Tags} &
    \SaysMatch{L}{e}{p'}{\gamma}{\_} &
    \SaysSubs{L}{\gamma}{p}{e'}
  }{
    \SaysUnexp{L}{\Tag{p}{p'}{e}}{e'}
  }
  
  \caption{Unexpansion}
  \label{fig:reval-unexpansion}
\end{figure}

\begin{lemma} \label{lemma:reval-exp-inverse}
  For all terms $e$, if $\SaysExp{L}{e}{e'}$ and
  $\SaysUnexp{L}{e'}{e''}$ then $e = e''$.
\end{lemma}
\begin{proof}
  .[FILL]
\end{proof}
\begin{corollary}
  Suppose that $e$ has honest tags [TODO].
  If $\SaysUnexp{L}{e}{e'}$ and $\SaysExp{L}{e'}{e''}$
  then $e = e''$.
\end{corollary}
\begin{proof}
  Since $e$ can unexpand, it must have exactly one tag.
  Since that tag is honest, it came from the expansion of some term $e^{*}$.
  By \cref{lemma:reval-exp-inverse}, $Expand(e^{*}) = e^{**}$ 
  and $Unexpand(e^{**}) = e^{*}$ for some $e^{**}$.

  (We write $Expand$ as shorthand for $\SaysExp{L}{\_}{\_}$;
   likewise for $Unexpand$.)
\end{proof}
