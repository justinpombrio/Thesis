% Greek αβγ

\chapter{Resugaring Evaluation Sequences}\label{chap:resugar-eval}

In this chapter, we tackle the challenge of combining syntactic sugar
with semantics[CITE, CITE]. Given a set of desugaring rules, of the
form shown in [REF], we show how to \emph{resugar program execution}:
to \emph{automatically} convert an evaluation sequence in the core
language into a representative evaluation sequence in the surface
syntax. Each step in the surface language emulates one or more steps
in the core language. The computed steps hide the transformation, thus
maintaining the abstraction provided by the surface language.

The chief challenge is to remain faithful to the original
semantics---we can't change the meaning of a program!---and to ensure
that the internals of the code introduced by the syntactic sugar does
not leak into the output. Our chief mechanisms for achieving this are
to (i) perform static checks on the desugaring definitions to ensure
they fall into the subset we can handle, and (ii) rewrite the
reduction relation with instrumentation to track the origin of terms.
These ideas are implemented in \Tool [LINK] (see also our prototypes from
prior publications [LINK, LINK]), and we formally verify key properties
of our approach, given simplifying assumptions, in the Coq proof
assistant.


\section{Our Approach}

We aim to compute sensible evaluation sequences in a surface language,
while remaining faithful to the core language's semantics.  One approach
would be to attempt to construct a lifted (to the surface language)
reduction-relation directly. It is unclear, however, how to do this
without making deep assumptions about the core language evaluator
(for instance, assuming that it is defined as a term-rewriting system that can be composed
with desugaring).

Our approach instead makes minimal assumptions about the
evaluator, treating it as a black-box (since it is often a complex
program that we may not be able to modify).
We assume only that we have access to a \emph{stepper} that
provides a sequence of evaluation steps (augmented with some
meta information) in the \emph{core} language. In 
\cref{sec:reval-lang} we show how to obtain such a stepper from a generic,
black-box
evaluator with a strategy that can be implemented by pre-processing
the program before evaluation.

Our high-level approach is to follow the evaluation steps in the core
language, find surface-level representations of some of the core
terms, and emit them. Not every core-level term will have a
surface-level representation; these steps will be skipped in the
output. The evaluation sequence shown, then, is the sequence of
surface-level representations of the core terms that were not
skipped. Central to this approach are three properties:

\begin{description}
\item[Emulation] Each term in the generated surface evaluation
  sequence desugars into the core term which it is meant to represent
  (up to term isomorphism).
\item[Abstraction] Code introduced by desugaring is never revealed in the
  surface evaluation sequence, and code originating from the original
  input program is never hidden by resugaring.
\item[Coverage] Resugaring is attempted on every core step, and as few
  core steps are skipped as possible.
\item[Hygiene] Both desugaring and resugaring preserve
  $\alpha$-equivalence on terms.
\end{description}

\section{Informal Solution Overview}
\label{sec:reval-exposition}

We first present the techniques used by our solution, and some subtleties,
informally. We choose a familiar desugaring example: the rewriting
of \Code{Or}, as used in languages like Lisp and Scheme. We assume
the surface language has \Code{Or} as a construct, while the core does
not. We present our examples using a traditional infix concrete syntax.

% Unexpansion
\subsection{Finding Surface Representations Preserving Emulation}

We start by defining a simple, binary version of \Code{Or} (that
let-binds its first argument in case it has side-effects):
\begin{Codes}
(Or α β) \(\To\) (Let [(Binding t α)]
                 (If t t β))
\end{Codes}
In this section we focus on abstract syntax and ignore
the mapping to it from concrete syntax.

Consider the surface term \Code{not(true) OR not(false)}. After
desugaring, this would evaluate as follows in the core language
(assuming a typical call-by-value evaluator):
\begin{Codes}
    let t = not(true) in
      if t then t else not(false)
\CoreStep let t = false in
      if t then t else not(false)
\CoreStep if false then false else not(false)
\CoreStep not(false)
\CoreStep true
\end{Codes}
In the surface language, we would wish to see this as (using dashed
arrows to denote reconstructed steps):
\begin{Codes}
    not(true) OR not(false)
\SurfStep false OR not(false)
\SurfStep not(false)
\SurfStep true
\end{Codes}
The first two terms in the core evaluation sequence are precisely the
expansions of the first two steps in the (hypothetical) surface evaluation
sequence. This suggests
we can \emph{unexpand} core terms into surface terms by running rules ``in
reverse'': matching against the \Sc{rhs} and substituting into the
corresponding \Sc{lhs}.
(To preserve Emulation, unexpansion must be an inverse of expansion: we
prove that this is so in \cref{sec:reval-inverses}.)
We will now show how the last two steps
may come about.

\subsection{Maintaining Abstraction}
\label{sec:reval-exposition-tagging}

When unexpanding, we should only unexpand code that
originated from desugaring. If the surface program itself is
\begin{Codes}
let t = not(true) in
  if t then t else not(false)
\end{Codes}
it should not unexpand into \Code{not(true) OR not(false)}:
this would be confusing and break the second clause of the Abstraction property.

We therefore augment subterms with a list of \emph{tags}, which
indicate which sugar it originated from.\marginpar{%
  Whereas the tags used in hygienic macro
  expansion~\cite{hygienic-macros} specify time steps, the tags in
  resugaring specify which sugar the code originated from.}
When the desugaring process encounters a sugar, it expands it and
tags its expansion as having resulted from that sugar.

Resugaring will attempt to reverse this process, by unexpanding every
tagged term. This unexpansion will fail if a tagged term no longer has
the form of the sugar's \Sc{rhs}. Likewise, resugaring as a whole will
fail if after all such unexpansion there are still core terms
leftover. In either circumstance, we conclude that there is no
surface representation of the core term and skip the step.

To illustrate this, we revisit the same core evaluation sequence as
before. ``\Code{\{Or:~\}}'' is a tag on the desugared expression that
indicates it originated from the \Code{Or} sugar, and ``\Code{\{Not:~\}}''
is a tag that indicates it originated from \Code{not} (which, being in
the core language, can be thought of as an identity sugar):
\begin{Codes}
    \{Or: let t = \{Not: not(true)\} in
      if t then t else \{Not: not(false)\}\}
\CoreStep \{Or: let t = false in
      if t then t else \{Not: not(false)\}\}
\CoreStep if false then false else \{Not: not(false)\}
\CoreStep \{Not: not(false)\}
\CoreStep true
\end{Codes}
The tags on the first two steps suggest that \Code{Or}'s
desugaring rule be applied in reverse. They can be unexpanded
because they match the \Sc{rhs} of \Code{Or}. The third step fails to
resugar because the \Code{if} is never unexpanded, and thus is a
leftover core term. This step is therefore skipped, yielding no
surface step. The second to last step successfully resugars. Finally,
the last step vacuously resugars, because atomic values are not tagged
and simply resugar to themselves.

\subsection{Striving for Coverage}

Emulation and Abstraction guarantee an accurate
surface evaluation sequence, but they do not guarantee a useful one. For
instance, the following evaluation sequence is perfectly consistent with
these two properties:
\begin{Codes}
    not(true) OR not(false)
\SurfStep true
\end{Codes}
However, a stepper that only shows the final step is unhelpful. We therefore
propose a third property, Coverage, which states that steps
are not ``unnecessarily'' skipped. We demonstrate Coverage in two
ways: in [REF], we give a sufficient condition for surface steps to be
shown, and our examples (\cref{sec:reval-pyret-example} and
\cref{sec:reval-examples}) show that in practice we do indeed obtain
detailed and useful surface evaluation sequences.

\subsection{Trading Abstraction for Coverage}
\label{sec:reval-trading}

Suppose the surface term \Code{α OR β OR γ} parses to
\Code{(Or α β γ)}. We therefore want to extend \Code{Or}
to handle more than two sub-terms.  We can do this with the desugaring
rule:
\begin{Codes}
(Or [α β] \(\To\)
  (Let [(Binding t α)]
      (If t t β)))
(Or [α β γ ...] \(\To\)
  (Let [(Binding t α)]
      (If t t (Or [β γ ...]))))
\end{Codes}
(Recall that we assume a prioritized semantics in which rules are tried in
order---the first rule whose \Sc{lhs} matches the invocation is
used---and that the ellipses denote zero or more repetitions
of the preceding pattern ([REF, \cite{macro-by-example}]).)

Consider the surface term \Code{(false OR false OR true)}. 
Given the revised definition of \Code{Or}, unexpansion would yield the
following lifted evaluation steps:
\begin{Codes}
    false OR false OR true
\SurfStep true
\end{Codes}
In particular, it correctly suppresses any presentation of the recursive
invocation of \Code{Or}
introduced by desugaring---precisely what Abstraction demands!
However, there are settings
(such as debugging or education) where the user might wish to see this
invocation, i.e., to obtain the surface evaluation sequence
\begin{Codes}
    false OR false OR true
\SurfStep false OR true
\SurfStep true
\end{Codes}
Thus, we let sugar authors make part of a rule's \Sc{rhs}
visible by prefixing it with \Code{!}. [TODO: impl] Here, writing the second
\Code{Or} rule as
\begin{Codes}
(Let [Binding t α]
    (If t t !(Or [β γ ...])))
\end{Codes}
yields the latter surface evaluation sequence.

This illustrates that there is a trade-off (which we make precise with
\cref{thm:reval-abstraction}) between Abstraction and Coverage.
Because the trade-off depends on
goals, we entrust it to the sugar author.  In the limit,
marking the entirety of each rule as transparent results in
an ordinary trace in the core, ignoring all sugar.

\subsection{Maintaining Hygiene}

[FILL: discuss hygiene and asds, from asd paper.]


\section{{\Resugarer} at Work}
\label{sec:reval-pyret-example}

We demonstrate how the techniques just described come together to show
surface evaluation sequences in the presence of sugar. Consider the
following program, written in the language Pyret (\url{pyret.org}), 
that computes the length of a list:
\begin{Codes}
    fun len(x):
      cases(List) x:
        | empty() => 0
        | link(_, tail) => len(tail) + 1
      end
    end
    len([1, 2])
\end{Codes}
This seemingly innocuous program contains a lot of sugar. The \Code{cases}
expression desugars into an application of the matchee's \Code{\_match}
method on an object containing code for each branch; the function
declaration desugars into a let binding to a lambda; addition desugars
into an application of a \Code{\_plus} method; and the list \Code{[1, 2]}
desugars into a chain of list constructors. Here is the full desugaring
(i.e., the code that will actually be run):
\begin{Codes}
len = fun(x):
    temp17 :: List = x
    temp17.["_match"](
      \{"empty" : fun(): 0 end,
       "link" : fun(_, tail):
                len(tail).["_plus"](1) end\},
      fun(): raise("cases: no cases matched");)
    end
len(list.["link"](1, list.["link"](2, list.["empty"])))
\end{Codes}
This degree and nature of expansion is not unique to Pyret.
It is also found in languages like Scheme, due
to the small size of the core, and in semantics like
$\lambda_{JS}$~\cite{lambda-js},
due to both the size of the core and the enormous complexity
of the surface language.

Nevertheless, here is the surface evaluation (pretty-)printed by {\Resugarer} (where
\Code{<func>} denotes a resolved functional):
\begin{Codes}
\SurfStep <func>([1, 2])
\SurfStep cases(List) [1, 2]:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end
\SurfStep <func>([2]) + 1
\SurfStep (cases(List) [2]:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end) + 1
\SurfStep <func>([]) + 1 + 1
\SurfStep (cases(List) []:
      | empty() => 0
      | link(_, tail) => len(tail) + 1
    end) + 1 + 1
\SurfStep 0 + 1 + 1
\SurfStep 1 + 1
\SurfStep 2
\end{Codes}
This sequence hides all the complexity of the core language.

\section{The Rewrite System}
\label{sec:reval-transformations}

We will present evaluation resugaring in three parts. First
(\cref{sec:reval-onerule}), we will describe how our rewrite system
works, up to the level of performing a single rewrite. Next
(\cref{sec:reval-manyrule}), we will describe how to use tags to fully
desugar and resugar terms, transforming not just a term but its subterms
as well. Finally (\cref{sec:reval-lifting}), we will show how to use the
rewrite system to lift core evaluation sequences to surface
evaluation sequences.


\section{The Transformation System}
\label{sec:reval-transformations}

We will present our system in three parts. First
(\cref{sec:reval-onerule}), we will describe how our transformation system
works, up to the level of performing a single transformation. Next
(\cref{sec:reval-manyrule}), we will describe how to use tags to fully
desugar and resugar terms, transforming not just a term but its subterms
as well. Finally (\cref{sec:reval-lifting}), we will show how to use the
transformation system to lift core evaluation sequences to surface
evaluation sequences.

\subsection{Performing a Single Transformation}
\label{sec:reval-onerule}

We begin by describing the form and application of our transformation
rules.

In order to reconstruct a surface term from its desugaring, some
information must be recorded; otherwise two different surface terms
that desugared to the same core term would be indistinguishable. We
therefore place \emph{tags} on terms as they are desugared. Each tag
has two patterns, which are approximately the \Sc{lhs} and \Sc{rhs} of
the sugar they originated from:
\begin{Table}
  term $e$ &$::=$& $...$ \\
  &$|$& $\Tag{p}{p'}{e}$
\end{Table}

%% We can now define \emph{desugaring} and \emph{resugaring} operations that
%% translate \Sc{ast}s in the surface language to \Sc{ast}s in the core language and
%% back.

%% Desugaring uses a helper function called \emph{expand} that expands a
%% single piece of syntactic sugar in a term. \emph{Expand} looks up a
%% desugaring function to apply based on the term's topmost node and
%% applies it. This function can be Turing-complete, and is written in
%% the host language. In order for resugaring to work, however,
%% desugaring must be \emph{compositional}, i.e., it must be parametric
%% over its subterms. Hence, instead of expanding the entire term $t$ at
%% once, \emph{expand} will first split it into a pattern and subterms,
%% and then only expand the \emph{pattern} $C$ to a new pattern
%% $C'$. \emph{Expand} then returns the pair $(C, C')$ of the old and new
%% pattern.

%% Desugaring of a term $t$ thus proceeds by calling $\textit{expand}(t)$
%% to obtain the pair of patterns $(C, C')$, using matching and
%% substitution to rewrite $C$ to $C'$, and recursively substituting
%% the desugared subterms of $t$. The newly desugared term will be
%% wrapped in a tag noting the original and new patterns. Later,
%% resugaring will make use of these tags to undo each of the desugaring
%% functions.

%% Desugaring makes use of two operations over nodes. \\
%% $\sugar{n}{C}$ looks up the desugaring function associated with node
%% type $n$ and applies it to pattern $C$, and $\head{t}$ splits the term
%% $t$ to obtain the pattern $C$ to be desugared. The pattern returned by
%% $\head{t}$ may need to be more than just the topmost node of
%% $t$. Take, for instance, a multi-armed let construct like
%% \code{let x = 4, y = x in x + y}.
%% One way of representing this term in our system is:
%% \begin{codes}
%% node(Let,
%%   node(Bind, decl(\(x\)), node(Num, val(\(4\))),
%%     node(Bind, decl(\(y\)), ref(\(x\))),
%%       node(EndBinds))),
%%   node(Plus, ref(\(x\)), ref(\(y\))))
%% \end{codes}
%% It would be important for \code{Let}'s desugaring function to be given
%% all of its bindings, so the pattern returned by $\head{}$ in this case
%% should be:
%% \begin{codes}
%% node(Let,
%%   node(Bind, \(\hole\sb{1}\), \(\hole\sb{2}\),
%%     node(Bind, \(\hole\sb{3}\), \(\hole\sb{4}\),
%%       node(EndBinds))),
%%   \(\hole\sb{5}\))
%% \end{codes}
%% While $\head{}$ could in principle be a complicated function, we
%% believe in practice it is sufficient to partition nodes into
%% \emph{primary} nodes like \code{Let} that can stand on their own, and
%% secondary nodes like \code{Bind} and \code{EndBinds} that are merely
%% part of the node above them; thus we define $\head{}$ in terms of a
%% $\textit{is-primary}$ predicate. $\textit{is-primary}$ will return
%% \code{true} for values, declarations, and references; it is language
%% specific for \texttt{nodes}.

%% Desugaring is formally defined in \cref{desugar}, and
%% resugaring in \cref{resugar}.%
%% \footnote{Notice that resugaring begins with a
%% \emph{resolve} step: this is only really necessary in case evaluation
%% copies a term, thus breaking the invariant that variable declarations
%% in resolved terms all have unique subscripts.}
%% Desugaring and resugaring are overloaded to
%% act on substitutions in the obvious way, e.g.,
%% $\desugar(\repl{\hole}{t}) = \repl{\hole}{(\desugar{t})}$.
%% Desugaring and resugaring are inverses of one another, up to a permutation of
%% variables.

%% To show this, we will rely on terms having \emph{honest tags}:
%% \begin{definition}
%% A term has \emph{honest tags} when for each subterm of the form
%% $\stag{C}{C'} t$, $t = (t \match C') \subs C'$.
%% \end{definition}

%% \begin{figure}
%% \begin{jtable}
%% $\typelabel{\Desugar{t}}{t}$ \\
%% $\Desugar{t}$ &$=$& $\desugar(\resolve{t})$ \\
%% $\desugar{\node{a}{n}{\ellipses{t_i}}}$
%%   &$=$& $\stag{C}{C'} (\desugar{(t \match C)} \subs C')$ \\
%%  &&when $\expand{t} = (C, C')$ \\
%%  &&where $t = \node{a}{n}{\ellipses{t_i}}$ \\
%% $\desugar{t}$ &$=$& $t$ \quad otherwise
%% \\ \\
%% $\typelabel{\expand{t}}{(C, C)}$ \\
%% $\expand{\node{a}{n}{\ellipses{t_i}}}$
%%   &$=$& $(C, C')$ \\
%%  &&when $\head{\node{a}{n}{\ellipses{t_i}}} = C$ \\
%%  &&and $\resolve{\sugar{n}{C}} = C'$ \\
%% $\typelabel{\head{t}}{C}$ \\
%% $\head{\node{a}{n}{\ellipses{t_i}}}$
%%   &$=$& $\node{a}{n}{\ellipses{\headRec{t_i}}}$ \\
%%  &&when $\textit{is-primary}(n)$ \\
%% $\headRec{\node{a}{n}{\ellipses{t_i}}}$
%%   &$=$& $\node{a}{n}{\ellipses{\headRec{t_i}}}$ \\
%%  &&when $\textit{not}(\textit{is-primary}(n))$ \\
%% $\headRec{t}$
%%   &$=$& $\fresh{i} \hole_i$ \quad otherwise
%% \end{jtable}
%% \caption{Desugaring}
%% \label{desugar}
%% \end{figure}

%% \begin{figure}
%% \begin{jtable}
%% \multicolumn{2}{l}{$\typelabel{\Resugar{t}}{t \text{ or \fail}}$} \\
%% $\Resugar{t}$ &$=$& $\unresolve{\resugar(\resolve{t})}$ \\
%% $\resugar(\stag{C}{C'} t)$ &$=$& $(\resugar(t \match C')) \subs C$ \\
%% &&(or {\fail} if $t \match C'$ does not match) \\
%% $\resugar{\node{a}{n}{\ellipses{t_i}}}$ &$=$& {\fail} \\
%% $\resugar{t}$ &$=$& $t$ \quad otherwise
%% \end{jtable}
%% \caption{Resugaring}
%% \label{resugar}
%% \end{figure}

%% \begin{lemma}
%% \label{desRes}
%% For all terms $t$ with honest tags, if
%% $\resugar{t} \neq \fail$ then $\desugar{\resugar{t}} \iso t$.
%% \end{lemma}
%% \begin{proof}[Proof Sketch]
%% Proceed by induction on $t$. The interesting case is when the term $t$ is
%% tagged:
%% \begin{jtable}
%% $\desugar{\resugar{\stag{C}{C'} t}}$
%%   &$=$& $\desugar((\resugar(t \match C')) \subs C)$ \\
%%     &&with $(C, C') = \expand{t'}$ for some $t'$ \\
%%   &$=$& $\stag{C}{C''}
%%          \desugar((\resugar(t \match C')) \subs C) \match C) \subs C''$ \\
%%     &&where $\expand{\resugar(t \match C')} = (C, C'')$ \\
%%     &&and $C' \iso C''$ \\
%%   &$=$& $\stag{C}{C''}
%%          \desugar{\resugar(t \match C')} \subs C''$ \\
%%     &&by \cref{subsMatch} \\
%%   &$\iso$& $\stag{C}{C''}
%%          (t \match C') \subs C''$ \\
%%     &&by I.H. \\
%%   &$\iso$& $\stag{C}{C'} t$ \\
%%     &&by \cref{matchSubs}
%% \end{jtable}
%% The first step (which introduces $t'$) relies on the tags having been
%% produced by a call to $\expand{}$.
%% \end{proof}

%% \begin{lemma}
%% \label{resDes}
%% For all terms $t$, $\resugar{\desugar{t}} = t$.
%% \end{lemma}
%% \begin{proof}
%% Proceed by induction on $t$. The interesting case is where the term $t$ is
%% not atomic:
%% \begin{jtable}
%% $\resugar{\desugar{t}}$
%%   &$=$& $\resugar{\stag{C}{C'}(\desugar(t \match C) \subs C')}$ \\
%%   &&with $\expand{t} = (C, C')$ \\
%%   &$=$& $\resugar{((\desugar(t \match C) \subs C')} \match C')
%%          \subs C$ \\
%%   &$=$& $\resugar{\desugar(t \match C)} \subs C$
%%     &by \cref{subsMatch} \\
%%   &$=$& $(t \match C) \subs C$
%%     &by I.H. \\
%%   &$=$& $t$
%%     &by \cref{matchSubs}
%% \end{jtable}
%% (The side condition for \cref{subsMatch} uses the fact that \\
%% $\domain{t \match C} = \holes{C} = \holes{C'}$.)
%% \end{proof}

%% \begin{lemma}
%% \label{resugar-resolve}
%% For all terms $t$,
%% $\resolve{\resugar{\resolve{t}}} \iso \resugar{\resolve{t}}$
%% \end{lemma}
%% \begin{proof}
%% The witness permutation is the mapping the second $\resolve{}$ enacts
%% on variable declarations. This mapping exists since resugaring can
%% neither drop nor duplicate variables. Now we must show that  variable
%% references are acted upon by the second $\resolve{}$ the same way as
%% their corresponding declarations. This amounts to asking weather each
%% variable reference $\refn{x_u}$ is in scope of exactly its declaration
%% $\decl{x_u}$. It is: it cannot be in scope of any \emph{other}
%% declaration, because the \emph{first} call to $\resolve{}$ gave them
%% all distinct subscripts, and it cannot be \emph{out} of scope of its
%% $\decl{x_u}$ because that would mean that resugaring caused an
%% identifier to become unbound, which could only happen if the initial
%% program contained an unbound identifier.
%% \end{proof}
