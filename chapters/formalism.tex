\chapter{Desugaring, Formally}\label{chap:formalism}

In this chapter, we give formal definitions for \Sc{ast}s and
desugaring that will be used throughout the rest of the thesis.  Most
relevantly, we assume that desugaring is given as a set of
pattern-based rewrite rules (a la Racket's \Code{syntax-rules}
[CITE]). This is important because it will form an expressive limit on
resugaring. Our techniques for resugaring evaluation sequences [REF] and
resugaring scope rules [REF] work on the kind of desugaring rules
given here, but no more. The chapter on resugaring type systems [REF]
will further restrict the allowed desuarging rules.

\section{ASTs}

For the purposes of resugaring, we place two requirements on
\textsc{ast}s. First, the \Sc{ast} must distinguish between variable
\emph{declarations} $\Decl{x}$ (i.e., binding sites), and variable
\emph{references} $\Refn{x}$ (i.e., uses). Second, each variable and
node in the \Sc{ast} must have a unique identity $u$ that
distinguishes it from other occurrences of the same variable or node.
(Exactly why these requirements are necessary will become clear in
[REF] and [REF].)
With this taken into account, the definition of \textsc{ast}s is
straightforward:
\marginpar{
  ~\\\vspace{1em}
  Why are lists necessary---can't they just be represented by
  \Sc{ast} nodes? We will shortly (REF) require \Sc{ast} nodes to have
  fixed arity.
}
\begin{Table}
constructor $C$ &$::=$& \textit{name} & syntactic construct name \\
ast $e$ &$::=$& $\Value$ & primitive value \\
  &$|$& $\Core{C}[u]{e_1 \dd e_n}$ & core \Sc{ast} node \\
  &$|$& $\Surf{C}[u]{e_1 \dd e_n}$ & surface \Sc{ast} node \\
  &$|$& $\Aux{C}[u]{e_1 \dd e_n}$ & auxilliary \Sc{ast} node \\
%  &$|$& $\Bitter{C}{e_1 \dd e_n}$ & bitter \Sc{ast} node \\
  &$|$& $[e_1 \dd e_n]$ & list \\
  &$|$& $\Refn[u]{x}$  & variable reference \\
  &$|$& $\Decl[u]{x}$  & variable declaration \\
%  &$|$& $\Tag{p}{p}{e}$ & (described in \cref{chap:resugar-eval})
%value $v$ &$::=$& $e$ & with no sugar invocations \\
\end{Table}




\section{Expansion}

\begin{Table}
ellipsis label $l$ &$::=$& \textit{name} & ellipsis label \\
%shape $\dot{e}$ &$::=$& ...e... & (same cases as $e$) \\
%  &$|$& $\bullet$ & hole \\
pattern $p$ &$::=$& $\PVarA$ & pattern variable \\
  &$|$& $\Core{C}{p_1 ... p_n}$ & syntactic construct \\
  &$|$& $\Surf{m}{p_1 ... p_n}$ & sugar invocation \\
  &$|$& $[ps]$ & list \\
  &$|$& $value$ & primitive value \\
  &$|$& $\Refn[i]{x}$ $|$ $\Decl[i]{x}$  & variable \\
  &$|$& $\Tag{p}{p}{e}$ & (used internally) \\
  &$|$& $\Fresh{x}{p}$ & fresh variable \\
seq. pattern $ps$ &$::=$& $\epsilon$ & empty sequence \\
  &$|$& $\Cons{p}{ps}$ & cons \\
  &$|$& $\Rep{p}{l}$ & ellipsis with label $l$ \\
  &$|$& $\EList{p_1 ... p_n}_l$ & ellipsis list (used internally) \\
fresh vars $F$ &$::=$& $\{x,...\}$ & fresh variable set \\
type env. $\Gamma$ &$::=$&
$\begin{cases}
  \PVarA:t, ... \\
  i \mapsto [\Gamma], ...
\end{cases}$ \\
substitution $\gamma$ &$::=$&
$\begin{cases}
  \PVarA \mapsto e, ... \\
  l \mapsto \EList{\gamma ... \gamma}, ... \\
  x \mapsto x, ...
\end{cases}$
\end{Table}

\begin{Table}
rewrite case $c$ &$::=$&
  $\DsRuleCase{(p_1,\,...,\,p_k)}{\Gamma}{p'}$ \\
desugaring rule $r$ &$::=$&
  $\DsRule{C}{k_1,...,k_n}$ \\
desugaring rules $rs$ &$::=$& $\{r_1, ..., r_n\}$
\end{Table}

\subsection{Matching and Substitution}

\begin{figure}
\TypeLabel{\SaysMatch{F}{e}{p}{\gamma}{p}}
\begin{multicols}{2}
  \Inference[m-pvar]{
    e \text{ is not a \Code{Tag}}
  }{
    \SaysMatch{F}{e}{\PVarA}{\{\PVarA \mapsto e\}}{\PVarA}
  }

  \Inference[m-str]{}{
    \SaysMatch{F}{string}{string}{\{\}}{string}
  }

  \Inference[m-empty]{}{
    \SaysMatch{F}{[\phantom{.}]}{[\epsilon]}{\{\}}{[\epsilon]}
  }

  \Inference[m-cons]{
    \SaysMatch{F}{e_1}{p}{\gamma_1}{p'} \\
    \SaysMatch{F}{[e_2,...,e_n]}{[ps]}{\gamma_s}{[ps']} \\
    \gamma_1 \cup \gamma_2 = \gamma
  }{
    \SaysMatch{F}{[e_1 ... e_n]}{[p,ps]}{\gamma}{[p',ps']}
  }

  \Inference[m-var-capture]{
    x \not\in F
  }{
    \SaysMatch{F}{x}{x}{\{\}}{x}
  }

  \Inference[m-var-fresh]{
    x \in F
  }{
    \SaysMatch{F}{y}{x}{\{x \mapsto y\}}{y}
  }

  \Inference[m-fresh]{
    \SaysMatch{F,x}{e}{p}{\gamma}{p'}
  }{
    \SaysMatch{F}{e}{\Fresh{x}{p}}{\gamma}{\Fresh{x}{p'}}
  }
\end{multicols}
\vspace{1em}

\Inference[m-ellipsis]{
  \SaysMatch{F}{e_1}{p}{\gamma_1}{p_1'} \;\cdots\; \SaysMatch{F}{e_n}{p}{\gamma_n}{p_n'}
}{
  \SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}
            {\{l \mapsto \EList{\gamma_1 ... \gamma_n}\}}
            {\EList{p_1' ... p_n'}_l}
}

\Inference[m-core]{
  \SaysMatch{F}{e_1}{p_1}{\gamma_1}{p_1'} \;\cdots\; \SaysMatch{F}{e_n}{p_n}{\gamma_n}{p_n'} &
}{
  \SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}
            {\gamma_1 \cup ... \cup \gamma_n}
            {\Core{C}{p_1' ... p_n'}}
}
  
\Inference[m-tag]{
  \SaysMatch{F}{e}{p}{\gamma}{p'}
}{
  \SaysMatch{F}{\Tag{p_{lhs}}{p_{rhs}}{e}}{p}{\gamma}{\Tag{p_{lhs}}{p_{rhs}}{p'}}
}

\caption{Matching}
\end{figure}


\begin{figure}
\TypeLabel{\SaysSubs{F}{\gamma}{p}{e}}
\begin{multicols}{2}
  \Inference[s-pvar]{
    \PVarA \mapsto e \in \gamma
  }{
    \SaysSubs{F}{\gamma}{\PVarA}{e}
  }

  \Inference[s-str]{}{
    \SaysSubs{F}{\gamma}{string}{string}
  }

  \Inference[s-empty]{}{
    \SaysSubs{F}{\gamma}{[\epsilon]}{[\phantom{.}]}
  }

  \Inference[s-cons]{
    \SaysSubs{F}{\gamma}{p}{e_1} \\
    \SaysSubs{F}{\gamma}{[ps]}{[e_2 ... e_n]}
  }{
    \SaysSubs{F}{\gamma}{[p,ps]}{[e_1 e_2 ... e_n]}
  }

  \Inference[s-var-capture]{
    x \not\in \gamma
  }{
    \SaysSubs{F}{\gamma}{x}{x}
  }

  \Inference[s-var-fresh]{
    x \mapsto y \in \gamma
  }{
    \SaysSubs{F}{\gamma}{x}{y}
  }

  \Inference[s-fresh]{
    \SaysSubs{F}{\gamma,x \mapsto y}{p}{e} \text{ for fresh $y$}
  }{
    \SaysSubs{F}{\gamma}{\Fresh{x}{p}}{e}
  }
\end{multicols}
\vspace{1em}

\Inference[s-ellipsis]{
  l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma \\
  \SaysSubs{F}{\gamma_1}{p}{e_1} \;\cdots\; \SaysSubs{F}{\gamma_n}{p}{e_n}
}{
  \SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}
}

\Inference[s-ellipsis-list]{
  l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma \\
  \SaysSubs{F}{\gamma_1}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma_n}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\EList{p_1 ... p_n}}{[e_1 ... e_n]}
}

\Inference[s-core]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}
}

\Inference[s-sugar]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}
}

\Inference[s-tag]{
  \SaysSubs{F}{\gamma}{p}{e}
}{
  \SaysSubs{F}{\gamma}{\Tag{p_{lhs}}{p_{rhs}}{p}}{\Tag{p_{lhs}}{p_{rhs}}{e}}
}

\caption{Substitution}
\end{figure}

\begin{lemma}[matching and substitution]
  Matching and substitution are inverses:
%  $\SaysSubs{F}{\gamma}{p}{e}$, then $\SaysMatch{F}{e}{p}{\gamma}$.
\end{lemma}
\begin{proof}
  Induct on $p$.
  [FILL]
\end{proof}
%However, the reverse is not true. Matching does not undo substitution,
%because substitution in non-deterministic (because it generates fresh
%variables).

\subsection{Expansion}

See \cref{fig:expansion}.
[TODO: Replace step with something that looks like desugaring.]
[TODO: Replace $v$ with something that looks like core terms.]

\begin{figure}
  NOTES: Core terms are terms without Surf or Aux nodes. Desugaring
  takes a term and produces a core term. Each sugar lhs and rhs is a
  surface pattern. Pattern variables match against core terms.
  \begin{Table}
    $c$ &$::=$& $\Value$ \\
    &$|$& $\Refn{x}$ \\
    &$|$& $\Decl{x}$ \\
    &$|$& $\Core{C}{c \dd}$ \\
    &$|$& $\Tag{p}{p}{c}$ \\
    &$|$& $[c \dd]$ \\
    \\
    $E_{ds}$ &$::=$& $\square$ \\
    &$|$& $[c \dd E_{ds}\,e \dd]$ \\
    &$|$& $\Core{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Surf{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Aux{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Tag{p}{p}{E_{ds}}$
  \end{Table}

  \begin{multicols}{2}
  \TypeLabel{\SaysDesugar{L}{s}{c}}

  \Inference[desugar]{
    \SaysDss{L}{s}{c}
  }{
    \SaysDesugar{L}{s}{c}
  }

  \TypeLabel{\SaysDs{L}{e}{e}} 

  \Inference[ds-ctx]{
    \SaysExp{L}{e}{e'}
  }{
    \SaysDs{L}{E_{ds}[e]}{E_{ds}[e']}
  }
  \end{multicols}

  \TypeLabel{\SaysExp{L}{e}{e}}
  
  \Inference[exp-sugar]{
    L = G,rs &
    \DsRule{C}{k_1 ... k_n} \in rs \IS\\
    k_i = \DsRuleCase{(p_1,...,p_n)}{\Gamma}{F}{p_{rhs}} \IS\\
    \SaysMatch{L}{c_i}{p_i}{\gamma_i}{p_i'} \text{ for each $i$} \IS\\
    \SaysMatch{L}{\Surf{C}{c_1 ... c_n}}{\Surf{C}{p_1 ... p_n}}{\gamma}{p_{lhs}} \IS\\
    \gamma' \text{ gives fresh names to the variables in $F$} \IS\\
%    \gamma_1 \cup ... \cup \gamma_n \cup \gamma' = \gamma \IS\\
    \SaysSubs{F}{(\gamma \cup \gamma')}{p_{rhs}}{e'}
  }{
    \SaysExp{L}{\Surf{C}{c_1 ... c_n}}{\Tag{p_{lhs}}{p_{rhs}}{e'}}
  }
  
  \Inference[exp-core]{
    L = G,rs &
    C \not\in rs &
    p = \Surf{C}{\PVarA_1 ... \PVarA_n} &
    p' = \Core{C}{\PVarA_1 ... \PVarA_n}
  }{
    \SaysExp{L}{\Surf{C}{c_1 ... c_n}}{\Tag{p}{p'}{\Core{C}{c_1 ... c_n}}}
  }
  \caption{Expansion}
  \label{fig:expansion}
\end{figure}




\subsection{Type Soundness}

We prove soundness by way of progress + preservation:
\begin{theorem}[Soundness]
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysDss{L}{e}{v}$ where $\SaysExpr{L}{v}{t}$, or $e$ runs forever.
\end{theorem}
\begin{proof}
\Cref{thm:progress} (progress) and \cref{thm:preservation}
(preservation) together imply that either:
(i) $e$ is a value, or (ii) $\SaysDs{L}{e}{e'}$ and $\SaysExpr{L}{e'}{t}$.
Apply this repeatedly. Either $e$ eventually steps to a value $v$, and
has remained the same type $t$ throughout the evaluation, or $e$ never
halts.
\end{proof}

\begin{lemma}[Progress] \label{thm:progress}
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysDs{L}{e}{e'}$, or $e$ is a value.
\end{lemma}
\begin{proof}
  First, verify that our evaluation contexts include every case that
  isn't a value. Thus either $e$ is a value and we are done, or $e$
  contains a redex: $e=E[\Surf{m}{e_1 ... e_n}]$.
  In the latter case, we will show that $e$ can take a step because
  the ds-sugar rule applies. There are two premises that need to be
  satisfied:
  \begin{itemize}
    \item First, we must show that $m$ is bound in $L$. Since $e$
      type-checked, it must be: the only rule which can type-check a
      sugar invocation is p-sugar; this in turn must use rule
      g-sugar; finally g-sugar requires that $m \in L$.
    \item Second, we must show that the pattern match of $e_1,...,e_n$
      succeeds on any case ${\DsRuleCase{(p_1,...,p_n)}{\Gamma}{F}{p'}}$
      of the desugaring
      rule. By \cref{thm:exhaustion}, it does.
  \end{itemize}
\end{proof}

\begin{assumption}[Exhaustion] \label{thm:exhaustion}
  If the set of cases in a desugaring rule are exhaustive over
  $t_1,...,t_n$ according to our exhaustion checking algorithm, then
  for every possible argument list $e_1,...,e_n$ that matches the
  given types (i.e., $\SaysExpr{L}{e_1}{t_1},...,\SaysExpr{L}{e_n}{t_n}$),
  there is a case $k_i$ such that $e_1,...,e_n$ successfully matches
  against $k_i$. [TODO: prove]
\end{assumption}
\begin{proof}
  \emph{Not given}. We have not stated our exhaustion checking
  algorithm here, and so cannot prove it correct. We believe it is
  straightforward (if tedious).
\end{proof}

\begin{lemma}[Preservation] \label{thm:preservation}
  If $\SaysExpr{L}{e}{t}$ and $\SaysDs{L}{e}{e'}$, then $\SaysExpr{L}{e'}{t}$.
\end{lemma}
\begin{proof}
  Since $e$ can take an expansion step, it must have a redex (via
  ds-ctx): $e = E[\Surf{m}{e_1 ... e_n}]$. And furthermore (by ds-sugar) $m$
  must be bound in $L$, and there must be a first case of $m$ that
  matches $e$.  Call it $k_i = (p_1,...,p_n);\Gamma \To p'$. Then:
  \begin{ProofTable}
  By ds-case: & $\SaysMatch{L}{e_i}{p_i}{\gamma_i}$
    for some $\gamma_i$ for each $i$ & (1) \\
  and & $\SaysSubs{F}{\gamma_i \cup ...
    \cup \gamma_n}{p'}{e'}$ & (2) \\
  and & $\SaysDs{L}{E[e]}{E[e']}$ \\
  By e-sugar: & $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$ \\
  and & $\SaysRule{L}{m}{t_1 ... t_n}{t}$ \\
  and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
  By g-sugar: & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (4) \\
  and & $\SaysPatt{L}{\Gamma}{p'}{t}$ & (5)
  \end{ProofTable}
  By \cref{thm:matching} with (1), (3), and (4),
  $\SaysEnv{\gamma_i}{\Gamma}$ for each $i$. By \cref{thm:union},
  $\SaysEnv{\gamma_1 \cup ... \gamma_n}{\Gamma}$.
  Finally, by \cref{thm:substitution} with that last fact together
  with (2) and (5), $\SaysExpr{L}{e'}{t}$.
\end{proof}

\begin{lemma}[Union of Substitutions] \label{thm:union}
  If $\SaysEnv{L}{\gamma_1}{\Gamma}$ and $\SaysEnv{L}{\gamma_2}{\Gamma}$,
  then $\SaysEnv{L}{\gamma_1 \cup \gamma_2}{\Gamma}$.
\end{lemma}
\begin{proof}
  [TODO]
\end{proof}

\begin{lemma}[Matching] \label{thm:matching}
  If $\SaysPatt{L}{\Gamma}{p}{t}$
  and $\SaysExpr{L}{e}{t}$
  and $\SaysMatch{F}{e}{p}{\gamma}$,
  then $\SaysEnv{L}{\gamma}{\Gamma}$
\end{lemma}
\begin{proof}
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
    \begin{ProofTable}
      By p-str: & $\SaysPatt{L}{\Gamma}{string}{\TString}$ & fixes $t$ \\
      By m-str: & $\SaysMatch{F}{string}{\TString}{\EmptySubs}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, by $\gamma$-env, $\SaysEnv{F}{\EmptySubs}{\Gamma}$
    (this applies for any $\Gamma$).
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By p-refn or p-decl, 
    $\Gamma = \{\}$ and $t$ is {\TRefn} or {\TDecl}.
    By m-fresh, $e = y$ for some fresh name $y$, and $\gamma = \{\}$.
    And the conclusion follows: $\SaysEnv{L}{\{\}}{\{\}}$. [TODO]
  \item[$p = \PVarA$]
    \begin{ProofTable}
      By p-pvar: & $\SaysPatt{L}{\Gamma}{\PVarA}{t}$ & fixes $t$ \\
      and & $\PVarA: t \in \Gamma$ & (1) \\
      By m-pvar: & $\SaysMatch{F}{e}{\alpha}{\{\PVarA \mapsto e\}}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, using $\gamma$-env on the premise $\SaysExpr{L}{e}{t}$
    gives that $\SaysEnv{L}{\gamma}{\{\PVarA: t\}},\Gamma'$ for any
    $\Gamma'$. By (1), this is the form of $\Gamma$, so we can set
    $\Gamma'$ such that $\Gamma = {\{\PVarA: t\}},\Gamma'$, and we are done.
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-core: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (1) \\
      By m-core: &
        $\SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}{\gamma}$
        & fixes $e$ \\
      and & $\SaysMatch{F}{e_i}{p_i}{\gamma_i}$ for each $i$ & (2) \\
      and & $\gamma = \gamma_1 \cup ... \cup \gamma_n$ \\
      By e-core: & $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
    \end{ProofTable}
    Applying the I.H. to (1), (2), and (3) yeilds that
    $\SaysEnv{L}{\gamma_i}{\Gamma}$.
    By \cref{thm:union}, $\SaysEnv{L}{\gamma}{\Gamma}$.
  \item[$p = \Surf{m}{p_1 ... p_n}$] [FILL]
  \item[$p = [\epsilon{]}$] [TODO] By m-empty, $\gamma = \{\}$.
    By p-empty, $\Gamma = \{\}$. The goal follows: $\SaysEnv{L}{\{\}}{\{\}}$.
  \item[$p = [p,ps{]}$] [FILL]
  \item[$p = [\Rep{p}{l'}{]}$]
    \begin{ProofTable}
      By p-ellipsis: & $\SaysPatt{L}{\Gamma}{\Rep{p}{l'}}{[t]}$ & fixes $t$ \\
      and & $l' \mapsto [\Gamma'] \in \Gamma$ & (1) \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (2) \\
      By m-ellipsis: & $\SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}
        {\{l' \mapsto [\gamma_1 \cup ... \gamma_n]\}}$
        & fixes $e$, $\gamma$ \\
      and & $\SaysMatch{F}{e_i}{p}{\gamma_i}$ for each $i$ & (3) \\
      By e-list: & $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ & (4)
    \end{ProofTable}
    By the I.H. together with (2), (3), and (4),
    $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$.
    By \cref{thm:union},
    $\SaysEnv{L}{\gamma_1 \cup ... \gamma_n}{\Gamma'}$.
    Finally, by $\gamma$-env,
    $\SaysEnv{L}{\{l' \mapsto [\gamma_1 \cup ... \gamma_n]\}}
      {\{l' \mapsto [\Gamma']\}}$, which is compatible with the
      specification of $\Gamma$ in (1).
  \end{description}
\end{proof}

\begin{lemma}[Substitition] \label{thm:substitution}
  If $\SaysEnv{L}{\gamma}{\Gamma}$
  and $\SaysPatt{L}{\Gamma}{p}{t}$,
  and $\SaysSubs{F}{\gamma}{p}{e}$,
  then $\SaysExpr{L}{e}{t}$.
\end{lemma}
\begin{proof}
  .[TODO]: update proof (freshness)
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
  \item[$p = string$] By s-str, $\SaysSubs{F}{\gamma}{p}{string}$, so $e=string$.
    By p-str, $\SaysPatt{L}{\Gamma}{p}{\TString}$, so $t=\TString$.
    Finally, by e-str, $\SaysExpr{L}{e}{\TString}$ as desired.
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By s-fresh, $e = y$ for some fresh name $y$.
    By p-refn or p-decl, $t$ is either {\TRefn} or {\TDecl}.
    Our goal $\SaysExpr{L}{y}{t}$ follows by either e-refn or e-decl,
    respectively.
  \item[$p = \PVarA$] By rule s-pvar, $\PVarA \mapsto e \in \gamma$.
    By $\gamma$-env, $\alpha \mapsto t \in \Gamma$ and $\SaysExpr{L}{e}{t}$.
    Which is our goal; we are done.
    (Note that by $\gamma$-env, $\Gamma$ may have many \emph{other},
    unnecessary, bindings to pattern variables, but it must \emph{at least}
    contain a correct binding for $\alpha$.)
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-core: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ & (1) \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      By s-core: & $\SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (3)
    \end{ProofTable}
    Using the I.H. with (2) and (3) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Using e-core on that fact together with (1) gives that
    $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$, so we are done.
  \item[$p = \Surf{m}{p_1 ... p_n}$]
    \begin{ProofTable}
      By s-sugar: & $\SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (1) \\
      By p-sugar: & $\SaysPatt{L}{\Gamma}{\Surf{m}{p_1 ... p_n}}{t}$
        & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      and & $\SaysRule{L}{m}{t_1,...,t_n}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1) and (2) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Finally, using e-sugar on that fact together with (3) gives that
    $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$.
  \item[$p = [\epsilon{]}$]
    By s-empty, $\SaysSubs{F}{\gamma}{p}{[]}$, so $e=[]$.
    By p-empty, $\SaysPatt{L}{\EmptyEnv}{[\epsilon]}{[t]}$ (for some $t$).
    Finally, by e-list, $\SaysExpr{L}{[]}{[t]}$.
  \item[$p = [p,ps{]}$]
    \begin{ProofTable}
      By s-cons: & $\SaysSubs{F}{\gamma}{p}{e_1}$ & (1) \\
      and & $\SaysSubs{F}{\gamma}{[ps]}{[e_2 ... e_n]}$ & (2) \\
      and & $\SaysSubs{F}{\gamma}{[p, ps]}{[e_1 e_2 ... e_n]}$ & fixes $e$ \\
      By p-cons: & $\SaysPatt{L}{\Gamma}{p}{t}$ & (3) \\
      and & $\SaysPatt{L}{\Gamma}{[ps]}{[t]}$ & (4) \\
      and & $\SaysPatt{L}{\Gamma}{[p, ps]}{[t]}$ & fixes $t$
    \end{ProofTable}
    We can apply the I.H. using (1) and (3) and the assumption
    $\SaysEnv{L}{\gamma}{\Gamma}$ to get that $\SaysExpr{L}{e_1}{t}$.
    Likewise, the I.H. with (2) and (4) gives
    $\SaysExpr{L}{[e_2 ... e_n]}{[t]}$.
    By e-list (in reverse), $\SaysExpr{L}{e_2}{t} \cdots \SaysExpr{L}{e_n}{t}$.
    Finally, by e-list (forward), $\SaysExpr{L}{[e_1 e_2 ... e_n]}{[t]}$.
  \item[$p = [\Rep{p}{l}{]}$]
    \begin{ProofTable}
      By s-ellipsis: & $\SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}$ & fixes $e$ \\
      and & $l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma$ \\
      and & $\SaysSubs{F}{\gamma_i}{p}{e_i}$ for each $i$ & (1) \\
      By $\gamma$-env: & $l \mapsto \EList{\Gamma'} \in \Gamma$ \\
      and & $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$ & (2) \\
      By p-ellipsis: & $\SaysPatt{L}{\Gamma}{[\Rep{p}{l}]}{[t]}$ & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1), (2), and (3) proves that
    $\SaysExpr{L}{e_i}{t}$.
    Then, by e-list, $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ as desired.
  \end{description}
\end{proof}


\newpage
\section{Example}

\subsection{Define-struct}

\paragraph{Core AST}
\begin{Codes}
Stmts:
| [\{splicing-begin stmts:Stmts\} @rest:Stmts]
   binding stmts in rest
   providing stmts, rest

| [\{let x:Var v:Expr\} @rest:Stmts]
   binding x in rest

| [\{fun f:Var args:Args body:Expr\} @rest:Stmts]
   binding args in body, rest in body
   providing f, rest
\end{Codes}

%% ALTERNATIVELY:

%% Stmts:
%% | \{splicing-begin stmts:Stmts rest:Stmts\}
%%    binding stmts in rest
%%    providing stmts, rest

%% | \{let x:Var v:Expr rest:Stmts\}
%%    binding x in rest

%% | \{fun f:Var args:Args body:Expr rest:Stmts\}
%%    binding args in body, rest in body
%%    providing f, rest

%% | \{end\}

%% Params:
%% | \{param x:Var rest:Params\}
%% | \{end\}

\paragraph{Auxiliary AST}
\begin{Codes}
IStructFields:
| [field:IStructField ...fields:IStructFields]
  providing field, fields

IStructField:
| \{i-struct-field field:Str get:Var set:Var\}
  providing get, set
\end{Codes}

\paragraph{Surface AST}
\begin{Codes}
SurfStmts:
  .....
| [(define-struct name:Var fields:StructFields) @rest:SurfStmts]
  binding name in rest, fields in rest
  providing name, fields, rest

StructFields:
| [field:StructField ...fields:StructFields]
  providing field, fields

StructField:
| (struct-field field:Str get:Var set:Var)
  providing get, set
\end{Codes}

\paragraph{Desugaring Rules}
\begin{Codes}
   [(struct-field field:Str get:Var set:Var) @rest:IStructFields]
=> [\{i-struct-field field get set\} @rest]
  
   [(define-struct name:Var
      [(struct-field field:Str get:Var set:Var) ...]) @rest:SurfStmts]
=> [\{fun name [x ...] \{record [\{record-field field x\} ...]\}\}
    \{splicing-begin [\{fun get [rec] \{record-get rec field\}\} ...]\}
    \{splicing-begin [\{fun set [rec val] \{record-set rec field val\}\} ...]\}
    @rest]
\end{Codes}

\subsection{Pyret For Expressions}

To handle Pyret for-expressions, we need to add desugaring rules for
the \Code{for} and for its bindings. 
First, when a for-expression binding (e.g. \Code{n from 0}) desugars,
it will simply return its binding (\Code{n}) and its value (\Code{0}).
It can do so with the desugaring rule:
\begin{Codes}
   (s-for-bind l:Loc b:Bind v:Expr)
=> \{for-bind b v\}
\end{Codes}
where \Code{ForBind} is a new auxiliary type:
\begin{Codes}
ForBind += \{for-bind Bind Expr\}

with list scope:
  [\{for-bind b v\} bs ...]
  export b
  export bs
\end{Codes}

Then the surface grammar can be extended for \Code{for} expressions:
\begin{Codes}
Expr += (s-for Loc Expr [ForBind] Ann Expr Bool)
with scope:
  bind binds in body
\end{Codes}

Then for-expressions can be implemented with the desugaring rule:
\begin{Codes}
   (s-for l:Loc
          iter:Expr
          [\{for-bind bind:Bind value:Expr\} ...]@binds
          ann:Ann
          body:Expr
          blocky:Bool)
=> (Apply l iter
     [(Lambda l (CONCAT "for-body<" (FORMAT l false) ">")
        [] [bind ...] ann "" body None None blocky)
      value ...])
\end{Codes}

Notice that \Code{s-for} is pattern matching against the results of
desugaring the \Code{s-for-bind}s. The \Code{(CONCAT ...)} stuff is to
compute at compile time a name for this lambda, which is what Pyret
currently does.

\newcommand{\C}{\(\sb{c}\)}
\subsubsection{Desugaring Pyret For Expressions}
\begin{Codes}
   (s-for map
     [(s-for-bind x (list [(+ 1 2)]))]
     (* x x))
=> (s-for map [(s-for-bind x (list
     [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))] (* x x))
=> (s-for map [(s-for-bind x (Tag<(list a),(list\C a)> (list\C
     [(Tag<(+ a b),(+\C a b)> (+\C 1 2))])))] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})]
     (Tag<(* a b),(*\C a b)>
       (*\C x x)))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (Tag<(* a b),(*\C a b)> (*\C x x)))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))]))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(Tag<..,..> (lambda\C [x]
          (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))]))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..>(lambda\C [x]
          (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))])))
-> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..> (lambda\C [x]
           (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C [3]))])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..> (lambda\C [x] (* x x)))
        (Tag<(list a),(list\C a)> (list\C [3]))])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(lambda [x] (* x x))
        (list [3])])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (* x x)) (list [3])]))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (* x x)) (list [3])]))
  // iter=map, bind=[x], body=(* x x), value=[(list [3])]
<= (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}>
        \{for-bind x (list [3])\})]
     (* x x))
<= (s-for map
     [(s-for-bind x (list [3]))]
     (* x x))
\end{Codes}

