\chapter{Desugaring, Formally}

In this chapter, we give formal definitions for \Sc{ast}s and
desugaring that will be used throughout the rest of the thesis.  Most
relevantly, we assume that desugaring is given as a set of
pattern-based rewrite rules (a la Racket's \Code{syntax-rules}
[CITE]). This is important because it will form an expressive limit on
resugaring. My techniques for resugaring evaluation sequences [REF] and
resugaring scope rules [REF] work on the kind of desugaring rules
given here, but no more. The chapter on resugaring type systems [REF]
will further restrict the allowed desuarging rules.

\section{ASTs}

For the purposes of resugaring, we place two requirements on
\textsc{ast}s. First, the \Sc{ast} must distinguish between variable
\emph{declarations} (i.e., binding sites) $\Decl{x}$, and variable
\emph{references} (i.e., uses) $\Refn{x}$. Second, each variable and
node in the \Sc{ast} must have a unique identity $u$ that
distinguishes it from other occurrences of the same variable or node.
(Exactly why these requirements are necessary will become clear in
[REF] and [REF].)
With this taken into account, the definition of \textsc{ast}s is
straightforward:
\marginpar{
  ~\\\vspace{1em}
  Why are 'lists' necessary---can't they just be represented by
  \Sc{ast} nodes? We will shortly (REF) require \Sc{ast} nodes to have
  fixed arity.
}
\begin{Table}
constructor $C$ &$::=$& \textit{name} & syntactic construct name \\
ast $e$ &$::=$& $\Const$ & syntactic constant \\
  &$|$& $\Core{C}{e_1 \dd e_n}$ & core \Sc{ast} node \\
  &$|$& $\Surf{C}{e_1 \dd e_n}$ & surface \Sc{ast} node \\
  &$|$& $\Aux{C}{e_1 \dd e_n}$ & auxilliary \Sc{ast} node \\
%  &$|$& $\Bitter{C}{e_1 \dd e_n}$ & bitter \Sc{ast} node \\
  &$|$& $\Tag{p}{p}{e}$ & tagged node ($p$ defined later) \\
  &$|$& $[e_1 \dd e_n]$ & list \\
  &$|$& $\Refn[u]{x}$  & variable reference \\
  &$|$& $\Decl[u]{x}$  & variable declaration \\
%value $v$ &$::=$& $e$ & with no sugar invocations \\
\end{Table}

\section{Desugaring}

[FILL: pattern-based rules, matching/subs; copy prose]

\section{AST Signatures} % Or Syntype Checking

Language's \textsc{ast}s typically have well-formedness criteria that
restrict how they can be put together. For example, perhaps
expressions can only occur within statements; statements occur only
within blocks; or data definitions can only occur at the top
level. These restrictions are \emph{usually} enforced by parsing,
although this becomes more difficult in the precense of sugar
(e.g. Racket [CITE] [FILL]).

These well-formedness conditions can (largely) be captured by giving
each syntactic construct a \emph{signature} that assigns it an
\emph{arity} and a \emph{sort}, and specifies the sorts that its
children must have.

\begin{Table}
ast defn. $G$ &$::=$& $A \mapsto \{t_1, ... t_n\}$
  & (with no production $A_1 \mapsto A_2$) \\
syntactic category $A$ &$::=$& \textit{name} \\
syntax type $t$ &$::=$& $A$ & syntactic category \\
  &$|$& $\Core{C}{t_1 ... t_n}$ & syntactic construct \\
  &$|$& $[t]$ & list \\
  &$|$& String & string literal \\
  &$|$& Decl & variable declaration \\
  &$|$& Refn & variable reference \\
language $L$ &$::=$& $G, rs$
\end{Table}

Lemma: If rules grammar check, then e obeys Surf implies ds(e) obeys
Core.

Lemma: Normalizing a grammar does not change its language.

\paragraph{Exhaustion Checking}
We perform exhaustion checking to make sure that sugars cover all
possible cases of their arguments, but do not give the algorithm here.
It works by looking at \emph{shapes}: a shape is a pattern that
contains types in place of pattern variables. It is straightforward to
check whether an expression matches a shape, and to convert a pattern
into a shape. Exhaustion checking uses the fact that the expressions
that do \emph{not} match a shape can be expressed as a union of shapes.
[TODO: prove]

\begin{figure}

\TypeLabel{\SaysExpr{L}{e}{t}}

\begin{multicols}{2}
  
  \Inference[e-con]{
    A \mapsto \Core{C}{t_1 ... t_n} \in L \\
    \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{L}{e_n}{t_n}
  }{
    \SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}
  }

  \Inference[e-refn]{}{
    \SaysExpr{L}{\Refn{x}}{\TRefn}
  }

  \Inference[e-decl]{}{
    \SaysExpr{L}{\Decl{x}}{\TDecl}
  }

  \Inference[e-str]{}{
    \SaysExpr{L}{\textit{string}}{\TString}
  }

  \Inference[e-list]{
    \SaysExpr{L}{e_1}{t} \;\cdots\; \SaysExpr{L}{e_n}{t}
  }{
    \SaysExpr{L}{[e_1 ... e_n]}{[t]}
  }

  \Inference[e-sugar]{
    \SaysRule{L}{m}{t_1,...,t_n}{t} \\
    \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{L}{e_n}{t_n}
  }{
    \SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}
  }
\end{multicols}

\TypeLabel{\SaysPatt{L}{\Gamma}{p}{t}}

\begin{multicols}{2}

  \Inference[p-pvar]{
    \PVarA : t \in \Gamma
  }{
    \SaysPatt{L}{\Gamma}{\PVarA}{t}
  }

  \Inference[p-refn]{}{
    \SaysPatt{L}{\Gamma}{x}{\TRefn}
  }

  \Inference[p-decl]{}{
    \SaysPatt{L}{\Gamma}{x}{\TDecl}
  }

  \Inference[p-str]{}{
    \SaysPatt{L}{\Gamma}{\textit{string}}{\TString}
  }

  \Inference[p-con]{
    A \mapsto \Core{C}{t_1 ... t_n} \in L \\
    \SaysPatt{L}{\Gamma}{p_1}{t_1} \;\cdots\; \SaysPatt{L}{\Gamma}{p_n}{t_n}
  }{
    \SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}
  }

  \Inference[p-sugar]{
    \SaysRule{L}{m}{t_1,...,t_n}{t} \\
    \SaysPatt{L}{\Gamma}{p_1}{t_1} \;\cdots\; \SaysPatt{L}{\Gamma}{p_n}{t_n}
  }{
    \SaysPatt{L}{\Gamma}{\Surf{m}{p_1 ... p_n}}{t}
  }

  \Inference[p-empty]{}{
    \SaysPatt{L}{\Gamma}{[\epsilon]}[t]
  }

  \Inference[p-cons]{
    \SaysPatt{L}{\Gamma}{p}{t} \\
    \SaysPatt{L}{\Gamma}{[ps]}{[t]}
  }{
    \SaysPatt{L}{\Gamma}{[\Cons{p}{ps}]}{[t]}
  }

  \Inference[p-ellipsis]{
    l \mapsto \EList{\Gamma'} \in \Gamma & \SaysPatt{L}{\Gamma'}{p}{t}
  }{
    \SaysPatt{L}{\Gamma}{[\Rep{p}{l}]}{[t]}
  }
\end{multicols}

\TypeLabel{\SaysRule{L}{m}{t,...,t}{t}}
\Inference[g-sugar]{
  \DsRuleFancy
      {m}
      {(p_{11},...,p_{1n});\Gamma_1;F_1 \To p_1'}
      {(p_{k1},...,p_{kn});\Gamma_k;F_k \To p_k'}
      \in L \\
  \text{The cases are exhaustive over $t_1,...,t_n$ in $G$} \\
  \SaysPatt{L}{\Gamma_{i}}{p_{ij}}{t_j}
    \text{ for each $i \in 1..k, j \in 1..n$} \\
  \SaysPatt{L}{\Gamma_{i}}{p_i'}{t}
    \text{ for each $i \in 1..k$}
}{
  \SaysRule{L}{m}{t_1,...,t_n}{t}
}

\TypeLabel{\SaysEnv{L}{\gamma}{\Gamma}}
\Inference[$\gamma$-env]{
  \SaysExpr{L}{e_1}{t_1} \;\cdots\; \SaysExpr{e_n}{t_n} \\
  \SaysEnv{L}{\gamma_{11}}{\Gamma_1} \;\cdots\; \SaysEnv{L}{\gamma_{1j}}{\Gamma_1} \\
  ... \\
  \SaysEnv{L}{\gamma_{m1}}{\Gamma_m} \;\cdots\; \SaysEnv{L}{\gamma_{mk}}{\Gamma_m} \\
}{
  \SaysEnv{L}{
    \begin{cases}
      \PVarA_1 \mapsto e_1,\,...,\,\PVarA_n \mapsto e_n \\
      i_1 \mapsto [\gamma_{11},\,...,\,\gamma_{1j}] \\
      ... \\
      i_m \mapsto [\gamma_{m1},\,...,\,\gamma_{mk}]
    \end{cases}
  }{
    \Gamma',
    \begin{cases}
      \PVarA_1: t_1,\,...,\,\PVarA_n: t_n, \\
      %\PVarA_1': t_1',\,...,\,\PVarA_{n'}': t_{n'}' \\
      i_1 \mapsto [\Gamma_1],\,...,\,i_m \mapsto [\Gamma_m], \\
      %i_1' \mapsto [\Gamma_1'],\,...,\,i_{m'}' \mapsto [\Gamma_{m'}']
    \end{cases}
  }
}

\caption{Grammar Checking}
\end{figure}


\newpage
\section{Example}

\subsection{Define-struct}

\paragraph{Core AST}
\begin{Codes}
Stmts:
| [\{splicing-begin stmts:Stmts\} @rest:Stmts]
   binding stmts in rest
   providing stmts, rest

| [\{let x:Var v:Expr\} @rest:Stmts]
   binding x in rest

| [\{fun f:Var args:Args body:Expr\} @rest:Stmts]
   binding args in body, rest in body
   providing f, rest

ALTERNATIVELY:

Stmts:
| \{splicing-begin stmts:Stmts rest:Stmts\}
   binding stmts in rest
   providing stmts, rest

| \{let x:Var v:Expr rest:Stmts\}
   binding x in rest

| \{fun f:Var args:Args body:Expr rest:Stmts\}
   binding args in body, rest in body
   providing f, rest

| \{end\}

Params:
| \{param x:Var rest:Params\}
| \{end\}
\end{Codes}

\paragraph{Auxiliary AST}
\begin{Codes}
IStructFields:
| [field:IStructField ...fields:IStructFields]
  providing field, fields

IStructField:
| \{i-struct-field field:Str get:Var set:Var\}
  providing get, set
\end{Codes}

\paragraph{Surface AST}
\begin{Codes}
SurfStmts:
  .....
| [(define-struct name:Var fields:StructFields) @rest:SurfStmts]
  binding name in rest, fields in rest
  providing name, fields, rest

StructFields:
| [field:StructField ...fields:StructFields]
  providing field, fields

StructField:
| (struct-field field:Str get:Var set:Var)
  providing get, set
\end{Codes}

\paragraph{Desugaring Rules}
\begin{Codes}
   [(struct-field field:Str get:Var set:Var) @rest:IStructFields]
=> [\{i-struct-field field get set\} @rest]
  
   [(define-struct name:Var
      [(struct-field field:Str get:Var set:Var) ...]) @rest:SurfStmts]
=> [\{fun name [x ...] \{record [\{record-field field x\} ...]\}\}
    \{splicing-begin [\{fun get [rec] \{record-get rec field\}\} ...]\}
    \{splicing-begin [\{fun set [rec val] \{record-set rec field val\}\} ...]\}
    @rest]
\end{Codes}

\subsection{Pyret For Expressions}

To handle Pyret for-expressions, we need to add desugaring rules for
the \Code{for} and for its bindings. 
First, when a for-expression binding (e.g. \Code{n from 0}) desugars,
it will simply return its binding (\Code{n}) and its value (\Code{0}).
It can do so with the desugaring rule:
\begin{Codes}
   (s-for-bind l:Loc b:Bind v:Expr)
=> \{for-bind b v\}
\end{Codes}
where \Code{ForBind} is a new auxiliary type:
\begin{Codes}
ForBind += \{for-bind Bind Expr\}

with list scope:
  [\{for-bind b v\} bs ...]
  export b
  export bs
\end{Codes}

Then the surface grammar can be extended for \Code{for} expressions:
\begin{Codes}
Expr += (s-for Loc Expr [ForBind] Ann Expr Bool)
with scope:
  bind binds in body
\end{Codes}

Then for-expressions can be implemented with the desugaring rule:
\begin{Codes}
   (s-for l:Loc
          iter:Expr
          [\{for-bind bind:Bind value:Expr\} ...]@binds
          ann:Ann
          body:Expr
          blocky:Bool)
=> (Apply l iter
     [(Lambda l (CONCAT "for-body<" (FORMAT l false) ">")
        [] [bind ...] ann "" body None None blocky)
      value ...])
\end{Codes}

Notice that \Code{s-for} is pattern matching against the results of
desugaring the \Code{s-for-bind}s. The \Code{(CONCAT ...)} stuff is to
compute at compile time a name for this lambda, which is what Pyret
currently does.

\newcommand{\C}{\(\sb{c}\)}
\subsubsection{Desugaring Pyret For Expressions}
\begin{Codes}
   (s-for map
     [(s-for-bind x (list [(+ 1 2)]))]
     (* x x))
=> (s-for map [(s-for-bind x (list
     [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))] (* x x))
=> (s-for map [(s-for-bind x (Tag<(list a),(list\C a)> (list\C
     [(Tag<(+ a b),(+\C a b)> (+\C 1 2))])))] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})] (* x x))
=> (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}> \{for-bind x
       (Tag<(list a),(list\C a)> (list\C
         [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))\})]
     (Tag<(* a b),(*\C a b)>
       (*\C x x)))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (Tag<(* a b),(*\C a b)> (*\C x x)))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))]))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(Tag<..,..> (lambda\C [x]
          (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))]))
=> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..>(lambda\C [x]
          (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C
          [(Tag<(+ a b),(+\C a b)> (+\C 1 2))]))])))
-> (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..> (lambda\C [x]
           (Tag<(* a b),(*\C a b)> (*\C x x))))
        (Tag<(list a),(list\C a)> (list\C [3]))])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(Tag<..,..> (lambda\C [x] (* x x)))
        (Tag<(list a),(list\C a)> (list\C [3]))])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (Tag<..,..> (apply\C map [(lambda [x] (* x x))
        (list [3])])))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (* x x)) (list [3])]))
<= (Tag<(s-for iter
         [(Tag<(s-for-bind b v),\{for-bind b v\}>
             \{for-bind bind value\}) ...]
           body),
         (apply iter [(lambda [bind ...] body) value ...])>
      (apply map [(lambda [x] (* x x)) (list [3])]))
  // iter=map, bind=[x], body=(* x x), value=[(list [3])]
<= (s-for map
     [(Tag<(s-for-bind b v),\{for-bind b v\}>
        \{for-bind x (list [3])\})]
     (* x x))
<= (s-for map
     [(s-for-bind x (list [3]))]
     (* x x))
\end{Codes}

\section{Expressions}



\section{Expansion}

\begin{Table}
ellipsis label $l$ &$::=$& \textit{name} & ellipsis label \\
%shape $\dot{e}$ &$::=$& ...e... & (same cases as $e$) \\
%  &$|$& $\bullet$ & hole \\
pattern $p$ &$::=$& $\PVarA$ & pattern variable \\
  &$|$& $\Core{C}{p_1 ... p_n}$ & syntactic construct \\
  &$|$& $\Surf{m}{p_1 ... p_n}$ & sugar invocation \\
  &$|$& $[ps]$ & list \\
  &$|$& $string$ & string literal \\
  &$|$& $\Refn[i]{x}$ $|$ $\Decl[i]{x}$  & variable \\
seq. pattern $ps$ &$::=$& $\epsilon$ & empty sequence \\
  &$|$& $\Cons{p}{ps}$ & cons \\
  &$|$& $\Rep{p}{l}$ & ellipsis with label $l$ \\
  &$|$& $\EList{p_1 ... p_n}_l$ & ellipsis list (used internally) \\
fresh vars $F$ &$::=$& $\{x,...\}$ & fresh variable set \\
type env. $\Gamma$ &$::=$&
$\begin{cases}
  \PVarA:t, ... \\
  i \mapsto [\Gamma], ...
\end{cases}$ \\
substitution $\gamma$ &$::=$&
$\begin{cases}
  \PVarA \mapsto e, ... \\
  l \mapsto \EList{\gamma ... \gamma}, ... \\
  x \mapsto x, ...
\end{cases}$
\end{Table}

\begin{Table}
rewrite case $c$ &$::=$&
  $\DsRuleCase{(p_1,\,...,\,p_k)}{\Gamma}{F}{p'}$ \\
desugaring rule $r$ &$::=$&
  $\DsRule{C}{k_1,...,k_n}$ \\
desugaring rules $rs$ &$::=$& $\{r_1, ..., r_n\}$
\end{Table}

\subsection{Matching and Substitution}

\begin{figure}
\TypeLabel{\SaysMatch{F}{e}{p}{\gamma}{p}}
\begin{multicols}{2}
  \Inference[m-pvar]{}{
    \SaysMatch{F}{e}{\PVarA}{\{\PVarA \mapsto e\}}{\PVarA}
  }

  \Inference[m-capture]{
    x \not\in F
  }{
    \SaysMatch{F}{x}{x}{\{\}}{x}
  }

  \Inference[m-fresh]{
    x \in F
  }{
    \SaysMatch{F}{y}{x}{\{x \mapsto y\}}{y}
  }

  \Inference[m-str]{}{
    \SaysMatch{F}{string}{string}{\{\}}{string}
  }

  \Inference[m-empty]{}{
    \SaysMatch{F}{[\phantom{.}]}{[\epsilon]}{\{\}}{[\epsilon]}
  }

  \Inference[m-cons]{
    \SaysMatch{F}{e_1}{p}{\gamma_1}{p'} \\
    \SaysMatch{F}{[e_2,...,e_n]}{[ps]}{\gamma_s}{[ps']} \\
    \gamma_1 \DisjUnion \gamma_2 = \gamma
  }{
    \SaysMatch{F}{[e_1 ... e_n]}{[p,ps]}{\gamma}{[p',ps']}
  }
\end{multicols}
\vspace{1em}

\Inference[m-ellipsis]{
  \SaysMatch{F}{e_1}{p}{\gamma_1}{p_1'} \;\cdots\; \SaysMatch{F}{e_n}{p}{\gamma_n}{p_n'}
}{
  \SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}
            {\{l \mapsto \EList{\gamma_1 ... \gamma_n}\}}
            {\EList{p_1' ... p_n'}_l}
}

\Inference[m-con]{
  \SaysMatch{F}{e_1}{p_1}{\gamma_1}{p_1'} \;\cdots\; \SaysMatch{F}{e_n}{p_n}{\gamma_n}{p_n'} &
}{
  \SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}
            {\gamma_1 \cup ... \cup \gamma_n}
            {\Core{C}{p_1' ... p_n'}}
}

\caption{Matching}
\end{figure}


\begin{figure}
\TypeLabel{\SaysSubs{F}{\gamma}{p}{e}}
\begin{multicols}{2}
  \Inference[s-pvar]{
    \PVarA \mapsto e \in \gamma
  }{
    \SaysSubs{F}{\gamma}{\PVarA}{e}
  }

  \Inference[s-str]{}{
    \SaysSubs{F}{\gamma}{string}{string}
  }

  \Inference[s-capture]{
    x \not\in F
  }{
    \SaysSubs{F}{\gamma}{x}{x}
  }

  \Inference[s-fresh]{
    x \in F & x \mapsto y \in \gamma
  }{
    \SaysSubs{F}{\gamma}{x}{y}
  }

  \Inference[s-empty]{}{
    \SaysSubs{F}{\gamma}{[\epsilon]}{[\phantom{.}]}
  }

  \Inference[s-cons]{
    \SaysSubs{F}{\gamma}{p}{e_1} \\
    \SaysSubs{F}{\gamma}{[ps]}{[e_2 ... e_n]}
  }{
    \SaysSubs{F}{\gamma}{[p,ps]}{[e_1 e_2 ... e_n]}
  }
\end{multicols}
\vspace{1em}

\Inference[s-ellipsis]{
  l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma \\
  \SaysSubs{F}{\gamma_1}{p}{e_1} \;\cdots\; \SaysSubs{F}{\gamma_n}{p}{e_n}
}{
  \SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}
}

\Inference[s-ellipsis-list]{
  l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma \\
  \SaysSubs{F}{\gamma_1}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma_n}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\EList{p_1 ... p_n}}{[e_1 ... e_n]}
}

\Inference[s-con]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}
}

\Inference[s-sugar]{
  \SaysSubs{F}{\gamma}{p_1}{e_1} \;\cdots\; \SaysSubs{F}{\gamma}{p_n}{e_n}
}{
  \SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}
}

\caption{Substitution}
\end{figure}

\begin{lemma}[matching and substitution]
  Matching and substitution are inverses:
%  $\SaysSubs{F}{\gamma}{p}{e}$, then $\SaysMatch{F}{e}{p}{\gamma}$.
\end{lemma}
\begin{proof}
  Induct on $p$.
  [FILL]
\end{proof}
%However, the reverse is not true. Matching does not undo substitution,
%because substitution in non-deterministic (because it generates fresh
%variables).

\subsection{Expansion}

See \cref{fig:expansion}.
[TODO: Replace step with something that looks like desugaring.]
[TODO: Replace $v$ with something that looks like core terms.]

\begin{figure}
  NOTES: Core terms are terms without Surf or Aux nodes. Desugaring
  takes a term and produces a core term. Each sugar lhs and rhs is a
  surface pattern. Pattern variables match against core terms.
  \begin{Table}
    $c$ &$::=$& $\Const$ \\
    &$|$& $\Refn{x}$ \\
    &$|$& $\Decl{x}$ \\
    &$|$& $\Core{C}{c \dd}$ \\
    &$|$& $\Tag{p}{p}{c}$ \\
    &$|$& $[c \dd]$ \\
    \\
    $E_{ds}$ &$::=$& $\square$ \\
    &$|$& $[c \dd E_{ds}\,e \dd]$ \\
    &$|$& $\Core{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Surf{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Aux{C}{c \dd E_{ds}\,e \dd}$ \\
    &$|$& $\Tag{p}{p}{E_{ds}}$
  \end{Table}
  \TypeLabel{\SaysDs{L}{e}{e}}
  
  \Inference[ds-ctx]{
    \SaysExp{L}{e}{e'}
  }{
    \SaysDs{L}{E_{ds}[e]}{E_{ds}[e']}
  }

  \TypeLabel{\SaysExp{L}{e}{e}}
  
  \Inference[exp-sugar]{
    L = G,rs &
    \DsRule{C}{k_1 ... k_n} \in rs \IS\\
    k_i = \DsRuleCase{(p_1,...,p_n)}{\Gamma}{F}{p_{rhs}} \IS\\
    \SaysMatch{L}{c_i}{p_i}{\gamma_i}{p_i'} \text{ for each $i$} \IS\\
    \SaysMatch{L}{\Surf{C}{c_1 ... c_n}}{\Surf{C}{p_1 ... p_n}}{\gamma}{p_{lhs}} \IS\\
    \gamma' \text{ gives fresh names to the variables in $F$} \IS\\
%    \gamma_1 \cup ... \cup \gamma_n \cup \gamma' = \gamma \IS\\
    \SaysSubs{F}{(\gamma \cup \gamma')}{p_{rhs}}{e'}
  }{
    \SaysExp{L}{\Surf{C}{c_1 ... c_n}}{\Tag{p_{lhs}}{p_{rhs}}{e'}}
  }
  
  \Inference[exp-core]{
    L = G,rs &
    C \not\in rs &
    p = \Surf{C}{\PVarA_1 ... \PVarA_n} &
    p' = \Core{C}{\PVarA_1 ... \PVarA_n}
  }{
    \SaysExp{L}{\Surf{C}{c_1 ... c_n}}{\Tag{p}{p'}{\Core{C}{c_1 ... c_n}}}
  }
  \caption{Expansion}
  \label{fig:expansion}
\end{figure}

\begin{figure}
  NOTES: Surface terms are any untagged terms.
  \begin{Table}
    $s$ &$::=$& $\Const$ \\
    &$|$& $\Refn{x}$ \\
    &$|$& $\Decl{x}$ \\
    &$|$& $\Surf{C}{s \dd}$ \\
    &$|$& $[s \dd]$ \\
    \\
    $E_{rs}$ &$::=$& $\square$ \\
    &$|$& $\Core{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Surf{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Aux{C}{s \dd E_{rs}\,e \dd}$ \\
    &$|$& $\Tag{p}{p}{E_{rs}}$ \\
    &$|$& $[s \dd E_{rs}\,e \dd]$
  \end{Table}
  \TypeLabel{\SaysRs{L}{e}{e}}

  \Inference[rs-ctx]{
    \SaysUnexp{L}{e}{e'}
  }{
    \SaysRs{L}{E_{rs}[e]}{E_{rs}[e']}
  }

  \TypeLabel{\SaysUnexp{L}{e}{e}}

  \Inference[unexp-tag]{
    e \text{ has no Tags} &
    \SaysMatch{L}{e}{p'}{\gamma}{\_} &
    \SaysSubs{L}{\gamma}{p}{e'}
  }{
    \SaysUnexp{L}{\Tag{p}{p'}{e}}{e'}
  }
  
  \caption{Unexpansion}
  \label{fig:unexpansion}
\end{figure}

\begin{lemma} \label{lemma:exp-inverse}
  For all terms $e$, if $\SaysExp{L}{e}{e'}$ and
  $\SaysUnexp{L}{e'}{e''}$ then $e = e''$.
\end{lemma}
\begin{proof}
  .[FILL]
\end{proof}
\begin{corollary}
  Suppose that $e$ has honest tags [TODO].
  If $\SaysUnexp{L}{e}{e'}$ and $\SaysExp{L}{e'}{e''}$
  then $e = e''$.
\end{corollary}
\begin{proof}
  Since $e$ can unexpand, it must have exactly one tag.
  Since that tag is honest, it came from the expansion of some term $e^{*}$.
  By \cref{lemma:exp-inverse}, $Expand(e^{*}) = e^{**}$ 
  and $Unexpand(e^{**}) = e^{*}$ for some $e^{**}$.

  (We write $Expand$ as shorthand for $\SaysExp{L}{\_}{\_}$;
   likewise for $Unexpand$.)
\end{proof}




\subsection{Type Soundness}

We prove soundness by way of progress + preservation:
\begin{theorem}[Soundness]
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysDss{L}{e}{v}$ where $\SaysExpr{L}{v}{t}$, or $e$ runs forever.
\end{theorem}
\begin{proof}
\Cref{thm:progress} (progress) and \cref{thm:preservation}
(preservation) together imply that either:
(i) $e$ is a value, or (ii) $\SaysDs{L}{e}{e'}$ and $\SaysExpr{L}{e'}{t}$.
Apply this repeatedly. Either $e$ eventually steps to a value $v$, and
has remained the same type $t$ throughout the evaluation, or $e$ never
halts.
\end{proof}

\begin{lemma}[Progress] \label{thm:progress}
  If $\SaysExpr{L}{e}{t}$, then
  $\SaysDs{L}{e}{e'}$, or $e$ is a value.
\end{lemma}
\begin{proof}
  First, verify that our evaluation contexts include every case that
  isn't a value. Thus either $e$ is a value and we are done, or $e$
  contains a redex: $e=E[\Surf{m}{e_1 ... e_n}]$.
  In the latter case, we will show that $e$ can take a step because
  the ds-sugar rule applies. There are two premises that need to be
  satisfied:
  \begin{itemize}
    \item First, we must show that $m$ is bound in $L$. Since $e$
      type-checked, it must be: the only rule which can type-check a
      sugar invocation is p-sugar; this in turn must use rule
      g-sugar; finally g-sugar requires that $m \in L$.
    \item Second, we must show that the pattern match of $e_1,...,e_n$
      succeeds on any case ${\DsRuleCase{(p_1,...,p_n)}{\Gamma}{F}{p'}}$
      of the desugaring
      rule. By \cref{thm:exhaustion}, it does.
  \end{itemize}
\end{proof}

\begin{assumption}[Exhaustion] \label{thm:exhaustion}
  If the set of cases in a desugaring rule are exhaustive over
  $t_1,...,t_n$ according to our exhaustion checking algorithm, then
  for every possible argument list $e_1,...,e_n$ that matches the
  given types (i.e., $\SaysExpr{L}{e_1}{t_1},...,\SaysExpr{L}{e_n}{t_n}$),
  there is a case $k_i$ such that $e_1,...,e_n$ successfully matches
  against $k_i$. [TODO: prove]
\end{assumption}
\begin{proof}
  \emph{Not given}. We have not stated our exhaustion checking
  algorithm here, and so cannot prove it correct. We believe it is
  straightforward (if tedious).
\end{proof}

\begin{lemma}[Preservation] \label{thm:preservation}
  If $\SaysExpr{L}{e}{t}$ and $\SaysDs{L}{e}{e'}$, then $\SaysExpr{L}{e'}{t}$.
\end{lemma}
\begin{proof}
  Since $e$ can take an expansion step, it must have a redex (via
  ds-ctx): $e = E[\Surf{m}{e_1 ... e_n}]$. And furthermore (by ds-sugar) $m$
  must be bound in $L$, and there must be a first case of $m$ that
  matches $e$.  Call it $k_i = (p_1,...,p_n);\Gamma \To p'$. Then:
  \begin{ProofTable}
  By ds-case: & $\SaysMatch{L}{e_i}{p_i}{\gamma_i}$
    for some $\gamma_i$ for each $i$ & (1) \\
  and & $\SaysSubs{F}{\gamma_i \DisjUnion ...
    \DisjUnion \gamma_n}{p'}{e'}$ & (2) \\
  and & $\SaysDs{L}{E[e]}{E[e']}$ \\
  By e-sugar: & $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$ \\
  and & $\SaysRule{L}{m}{t_1 ... t_n}{t}$ \\
  and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
  By g-sugar: & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (4) \\
  and & $\SaysPatt{L}{\Gamma}{p'}{t}$ & (5)
  \end{ProofTable}
  By \cref{thm:matching} with (1), (3), and (4),
  $\SaysEnv{\gamma_i}{\Gamma}$ for each $i$. By \cref{thm:union},
  $\SaysEnv{\gamma_1 \DisjUnion ... \gamma_n}{\Gamma}$.
  Finally, by \cref{thm:substitution} with that last fact together
  with (2) and (5), $\SaysExpr{L}{e'}{t}$.
\end{proof}

\begin{lemma}[Union of Substitutions] \label{thm:union}
  If $\SaysEnv{L}{\gamma_1}{\Gamma}$ and $\SaysEnv{L}{\gamma_2}{\Gamma}$,
  then $\SaysEnv{L}{\gamma_1 \DisjUnion \gamma_2}{\Gamma}$.
\end{lemma}
\begin{proof}
  [TODO]
\end{proof}

\begin{lemma}[Matching] \label{thm:matching}
  If $\SaysPatt{L}{\Gamma}{p}{t}$
  and $\SaysExpr{L}{e}{t}$
  and $\SaysMatch{F}{e}{p}{\gamma}$,
  then $\SaysEnv{L}{\gamma}{\Gamma}$
\end{lemma}
\begin{proof}
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
    \begin{ProofTable}
      By p-str: & $\SaysPatt{L}{\Gamma}{string}{\TString}$ & fixes $t$ \\
      By m-str: & $\SaysMatch{F}{string}{\TString}{\EmptySubs}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, by $\gamma$-env, $\SaysEnv{F}{\EmptySubs}{\Gamma}$
    (this applies for any $\Gamma$).
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By p-refn or p-decl, 
    $\Gamma = \{\}$ and $t$ is {\TRefn} or {\TDecl}.
    By m-fresh, $e = y$ for some fresh name $y$, and $\gamma = \{\}$.
    And the conclusion follows: $\SaysEnv{L}{\{\}}{\{\}}$. [TODO]
  \item[$p = \PVarA$]
    \begin{ProofTable}
      By p-pvar: & $\SaysPatt{L}{\Gamma}{\PVarA}{t}$ & fixes $t$ \\
      and & $\PVarA: t \in \Gamma$ & (1) \\
      By m-pvar: & $\SaysMatch{F}{e}{\alpha}{\{\PVarA \mapsto e\}}$
        & fixes $\gamma$
    \end{ProofTable}
    Finally, using $\gamma$-env on the premise $\SaysExpr{L}{e}{t}$
    gives that $\SaysEnv{L}{\gamma}{\{\PVarA: t\}},\Gamma'$ for any
    $\Gamma'$. By (1), this is the form of $\Gamma$, so we can set
    $\Gamma'$ such that $\Gamma = {\{\PVarA: t\}},\Gamma'$, and we are done.
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-con: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (1) \\
      By m-con: &
        $\SaysMatch{F}{\Core{C}{e_1 ... e_n}}{\Core{C}{p_1 ... p_n}}{\gamma}$
        & fixes $e$ \\
      and & $\SaysMatch{F}{e_i}{p_i}{\gamma_i}$ for each $i$ & (2) \\
      and & $\gamma = \gamma_1 \DisjUnion ... \DisjUnion \gamma_n$ \\
      By e-con: & $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ for each $i$ & (3) \\
    \end{ProofTable}
    Applying the I.H. to (1), (2), and (3) yeilds that
    $\SaysEnv{L}{\gamma_i}{\Gamma}$.
    By \cref{thm:union}, $\SaysEnv{L}{\gamma}{\Gamma}$.
  \item[$p = \Surf{m}{p_1 ... p_n}$] [FILL]
  \item[$p = [\epsilon{]}$] [TODO] By m-empty, $\gamma = \{\}$.
    By p-empty, $\Gamma = \{\}$. The goal follows: $\SaysEnv{L}{\{\}}{\{\}}$.
  \item[$p = [p,ps{]}$] [FILL]
  \item[$p = [\Rep{p}{l'}{]}$]
    \begin{ProofTable}
      By p-ellipsis: & $\SaysPatt{L}{\Gamma}{\Rep{p}{l'}}{[t]}$ & fixes $t$ \\
      and & $l' \mapsto [\Gamma'] \in \Gamma$ & (1) \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (2) \\
      By m-ellipsis: & $\SaysMatch{F}{[e_1 ... e_n]}{[\Rep{p}{l}]}
        {\{l' \mapsto [\gamma_1 \DisjUnion ... \gamma_n]\}}$
        & fixes $e$, $\gamma$ \\
      and & $\SaysMatch{F}{e_i}{p}{\gamma_i}$ for each $i$ & (3) \\
      By e-list: & $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ \\
      and & $\SaysExpr{L}{e_i}{t_i}$ & (4)
    \end{ProofTable}
    By the I.H. together with (2), (3), and (4),
    $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$.
    By \cref{thm:union},
    $\SaysEnv{L}{\gamma_1 \DisjUnion ... \gamma_n}{\Gamma'}$.
    Finally, by $\gamma$-env,
    $\SaysEnv{L}{\{l' \mapsto [\gamma_1 \DisjUnion ... \gamma_n]\}}
      {\{l' \mapsto [\Gamma']\}}$, which is compatible with the
      specification of $\Gamma$ in (1).
  \end{description}
\end{proof}

\begin{lemma}[Substitition] \label{thm:substitution}
  If $\SaysEnv{L}{\gamma}{\Gamma}$
  and $\SaysPatt{L}{\Gamma}{p}{t}$,
  and $\SaysSubs{F}{\gamma}{p}{e}$,
  then $\SaysExpr{L}{e}{t}$.
\end{lemma}
\begin{proof}
  Induction on $p$.
  \begin{description}
  \item[$p = string$]
  \item[$p = string$] By s-str, $\SaysSubs{F}{\gamma}{p}{string}$, so $e=string$.
    By p-str, $\SaysPatt{L}{\Gamma}{p}{\TString}$, so $t=\TString$.
    Finally, by e-str, $\SaysExpr{L}{e}{\TString}$ as desired.
  \item[$p = x \not\in F$] (Analogous.)
  \item[$p = x \in F$] By s-fresh, $e = y$ for some fresh name $y$.
    By p-refn or p-decl, $t$ is either {\TRefn} or {\TDecl}.
    Our goal $\SaysExpr{L}{y}{t}$ follows by either e-refn or e-decl,
    respectively.
  \item[$p = \PVarA$] By rule s-pvar, $\PVarA \mapsto e \in \gamma$.
    By $\gamma$-env, $\alpha \mapsto t \in \Gamma$ and $\SaysExpr{L}{e}{t}$.
    Which is our goal; we are done.
    (Note that by $\gamma$-env, $\Gamma$ may have many \emph{other},
    unnecessary, bindings to pattern variables, but it must \emph{at least}
    contain a correct binding for $\alpha$.)
  \item[$p = \Core{C}{p_1 ... p_n}$]
    \begin{ProofTable}
      By p-con: & $\SaysPatt{L}{\Gamma}{\Core{C}{p_1 ... p_n}}{A}$ & fixes $t$ \\
      and & $A \mapsto \Core{C}{t_1 ... t_n} \in L$ & (1) \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      By s-con: & $\SaysSubs{F}{\gamma}{\Core{C}{p_1 ... p_n}}{\Core{C}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (3)
    \end{ProofTable}
    Using the I.H. with (2) and (3) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Using e-con on that fact together with (1) gives that
    $\SaysExpr{L}{\Core{C}{e_1 ... e_n}}{A}$, so we are done.
  \item[$p = \Surf{m}{p_1 ... p_n}$]
    \begin{ProofTable}
      By s-sugar: & $\SaysSubs{F}{\gamma}{\Surf{m}{p_1 ... p_n}}{\Surf{m}{e_1 ... e_n}}$
        & fixes $e$ \\
      and & $\SaysSubs{F}{\gamma}{p_i}{e_i}$ for each $i$ & (1) \\
      By p-sugar: & $\SaysPatt{L}{\Gamma}{\Surf{m}{p_1 ... p_n}}{t}$
        & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma}{p_i}{t_i}$ for each $i$ & (2) \\
      and & $\SaysRule{L}{m}{t_1,...,t_n}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1) and (2) gives that
    $\SaysExpr{L}{e_i}{t_i}$ for each $i$.
    Finally, using e-sugar on that fact together with (3) gives that
    $\SaysExpr{L}{\Surf{m}{e_1 ... e_n}}{t}$.
  \item[$p = [\epsilon{]}$]
    By s-empty, $\SaysSubs{F}{\gamma}{p}{[]}$, so $e=[]$.
    By p-empty, $\SaysPatt{L}{\EmptyEnv}{[\epsilon]}{[t]}$ (for some $t$).
    Finally, by e-list, $\SaysExpr{L}{[]}{[t]}$.
  \item[$p = [p,ps{]}$]
    \begin{ProofTable}
      By s-cons: & $\SaysSubs{F}{\gamma}{p}{e_1}$ & (1) \\
      and & $\SaysSubs{F}{\gamma}{[ps]}{[e_2 ... e_n]}$ & (2) \\
      and & $\SaysSubs{F}{\gamma}{[p, ps]}{[e_1 e_2 ... e_n]}$ & fixes $e$ \\
      By p-cons: & $\SaysPatt{L}{\Gamma}{p}{t}$ & (3) \\
      and & $\SaysPatt{L}{\Gamma}{[ps]}{[t]}$ & (4) \\
      and & $\SaysPatt{L}{\Gamma}{[p, ps]}{[t]}$ & fixes $t$
    \end{ProofTable}
    We can apply the I.H. using (1) and (3) and the assumption
    $\SaysEnv{L}{\gamma}{\Gamma}$ to get that $\SaysExpr{L}{e_1}{t}$.
    Likewise, the I.H. with (2) and (4) gives
    $\SaysExpr{L}{[e_2 ... e_n]}{[t]}$.
    By e-list (in reverse), $\SaysExpr{L}{e_2}{t} \cdots \SaysExpr{L}{e_n}{t}$.
    Finally, by e-list (forward), $\SaysExpr{L}{[e_1 e_2 ... e_n]}{[t]}$.
  \item[$p = [\Rep{p}{l}{]}$]
    \begin{ProofTable}
      By s-ellipsis: & $\SaysSubs{F}{\gamma}{[\Rep{p}{l}]}{[e_1 ... e_n]}$ & fixes $e$ \\
      and & $l \mapsto \EList{\gamma_1 ... \gamma_n} \in \gamma$ \\
      and & $\SaysSubs{F}{\gamma_i}{p}{e_i}$ for each $i$ & (1) \\
      By $\gamma$-env: & $l \mapsto \EList{\Gamma'} \in \Gamma$ \\
      and & $\SaysEnv{L}{\gamma_i}{\Gamma'}$ for each $i$ & (2) \\
      By p-ellipsis: & $\SaysPatt{L}{\Gamma}{[\Rep{p}{l}]}{[t]}$ & fixes $t$ \\
      and & $\SaysPatt{L}{\Gamma'}{p}{t}$ & (3)
    \end{ProofTable}
    Using the I.H. with (1), (2), and (3) proves that
    $\SaysExpr{L}{e_i}{t}$.
    Then, by e-list, $\SaysExpr{L}{[e_1 ... e_n]}{[t]}$ as desired.
  \end{description}
\end{proof}

\section{Scope Checking}

(See \cref{fig:scope}.)

\begin{figure}
\TypeLabel{\SaysScope{\Sigma}{e}
  {\{\Decl{x}\}}
  {\{\Refn{x}\}}
  {\{\Decl{x}\}}
  {\{\Refn{x}\mapsto\Decl{x}\}}}

\Inference[scope-e-decl]{}{
  \SaysScope{\Sigma}{\Decl{x}}{\{\Decl{x}\}}{\{\}}{\{\Decl{x}\}}{\{\}}
}

\Inference[scope-e-refn]{}{
  \SaysScope{\Sigma}{\Refn{x}}{\{\}}{\{\Refn{x}\}}{\{\}}{\{\}}
}

\Inference[scope-e-con]{
  \Sigma[C] = \sigma \vspace{0.1em} \IS\\
  \SaysScope{\Sigma}{e_i}{P_i}{R_i}{B_i} \text{ for } i \in 1..n \IS\\
  S = \SetSuchThat{
    \Decl[a]{x} \mapsto \Decl[b]{x}
  }{
    \Decl[a]{x} \in P_i,\;
    \Decl[b]{x} \in P_j,\;
    \Bind{\sigma}{i}{j}
  } \IS\\
  B = \SetSuchThat{
    \Refn[a]{x} \mapsto \Decl[b]{x}
  }{
    \Refn[a]{x} \in R_i,\;
    \Decl[b]{x} \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    \Decl[b]{x} \not\in \Domain{S}
  } \IS\\
  R = \SetSuchThat{
    \Refn[a]{x}
  }{
    \Refn[a]{x} \in R_i,\;
    \NotExists{\Decl[b]{x}}{\Refn[a]{x} \mapsto \Decl[b]{x} \in B\}}
  } \IS\\
  P = \SetSuchThat{
    \Decl[a]{x}
  }{
    \Decl[a]{x} \in P_i,\;
    \Prov{\sigma}{i},\;
    \Decl[a]{x} \not\in \Domain{S}
  }
}{
  \SaysScope{\Sigma}{\Core{C}{e_1 ... e_n}}{P}{R}{B}
}


\Inference[scope-p-con]{
  \Sigma[C] = \sigma \vspace{0.1em} \IS\\
  \SaysScope{\Sigma}{p_i}{P_i}{R_i}{B_i} \text{ for } i \in 1..n \IS\\
  S = \SetSuchThat{
    a \mapsto b
  }{
    a \in P_i,\;
    b \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    \SaysCanShadow{F}{a}{b}
  } \IS\\
  B = \SetSuchThat{
    a \mapsto b
  }{
    a \in R_i,\;
    b \in P_j,\;
    \Bind{\sigma}{i}{j},\;
    b \not\in \Domain{S},\;
    \SaysCanBind{F}{a}{b}
  } \IS\\
  R = \SetSuchThat{
    a
  }{
    a \in R_i,\;
    (\NotExists{b}{a \mapsto b \in B\}}
    \text{ or $a$ is a pattern var})
  } \IS\\
  P = \SetSuchThat{
    a
  }{
    a \in P_i,\;
    \Prov{\sigma}{i},\;
    a \not\in \Domain{S}
  }
}{
  \SaysScope{\Sigma}{\Core{C}{p_1 ... p_n}}{P}{R}{B}
}

Two checks to make: fresh vars don't bind to non-fresh vars, and named
vars only bind to vars of the same name:
\begin{multicols}{3}
  \Inference{}{
    \SaysCanBind{F}{\Refn[1]{x}}{\Decl[2]{x}}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanBind{F}{\Refn[1]{x}}{\PVarA}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanBind{F}{\PVarA}{\Decl[1]{x}}
  }
  \Inference{}{
    \SaysCanBind{F}{\PVarA}{\PVarB}
  }
  \Inference{}{
    \SaysCanShadow{F}{\Decl[1]{x}}{\Decl[2]{x}}
  }
  \Inference{
    x \not\in F
  }{
    \SaysCanShadow{F}{\Decl[1]{x}}{\PVarA}
  }
\end{multicols}

\caption{Scope Checking Rules}
\label{fig:scope}
\end{figure}
