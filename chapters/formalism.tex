\chapter{Desugaring, Formally}\label{chap:formalism}

In this chapter, we set the groundwork of terminology and notation
that will be used throughout the rest of the thesis.
Most relevantly, we assume that desugaring is given (externally to the
language) as a set of pattern-based rewrite rules (a la Scheme's \Code{syntax-rules}
[CITE]). This is important because it will form an expressive limit on
resugaring. Our techniques for resugaring evaluation sequences \cref{chap:resugar-eval},
scope rules \cref{chap:resugar-scope}, and type systems \cref{chap:resugar-type}
work on the kind of desugaring rules given here, but no more.
Some chapters go beyond what is shown here: for instance, the
evaluation resugaring chapter (\cref{chap:resugar-eval}) formally
supports ellipses (which are not shown here), and the scope resugaring
chapter is agnostic to the order of desugaring (which is assumed to be
OI here).

[TODO: rewrite after this point: remove ellipses.]

\section{ASTs}\label{sec:formal-term}

For the purposes of resugaring, we require \Sc{ast}s to make two
distinctions explicit.  First, the \Sc{ast} must distinguish between
variable \emph{declarations} $\Decl{x}$ (i.e., binding sites), and
variable \emph{references} $\Refn{x}$ (i.e., uses).  Second, each
variable and node in the \Sc{ast} must have a unique identity $i$ that
distinguishes it from other occurrences of the same variable or node.
Exactly why these requirements are necessary will become clear in
[REF] and [REF], respectively.

We will refer to \Sc{ast}s (and parts of \Sc{ast}s)
as \emph{terms}, and write them $e$.\marginpar{%
  While $t$ would be a more obvious letter to use for terms, we use it
  to refer to types in \cref{chap:resugar-types}.
}
Terms can be inductively defined as:
\begin{Table}
constructor $C$ &$::=$& \textit{name} & syntactic construct name \\
term $e$ &$::=$& $\Value$ & primitive value \\
  &$|$& $\Node{C}[i]{e_1 \dd e_n}$ & \Sc{ast} node \\
  &$|$& $[e_1 \dd e_n]$ & list \\
  &$|$& $\Refn[i]{x}$  & variable reference \\
  &$|$& $\Decl[i]{x}$  & variable declaration \\
\end{Table}

Nodes must have fixed arity, so lists are used when a node needs to
contain an arbitrary number of subterms. All of the work in this
thesis will be agnostic to the representation of values, and never
inspect or modify one.


\section{Patterns}

Our desugaring formalism will be based on \emph{patterns}: desugaring will
proceed by \emph{matching} a \Sc{lhs} pattern against a term, and then
\emph{substituting} into the \Sc{rhs} pattern.

Our definition of patterns determines both the expressiveness of the
resulting transformation system and the ability to formally reason about
it. There is a natural trade-off between the two. We pick a definition similar to
that of Scheme \Code{syntax-rules}-style macros, though without guard
expressions.

Formally, our patterns are \emph{regular tree
  expressions}~\cite{regular-tree-expressions}. Regular tree
expressions $\mathit{trx}$ are the natural extension of regular
expressions to handle trees: they add a primitive $\Node{C}{\mathit{trx}_1
\,...\,\mathit{trx}_n}$ for matching a tree node labeled $C$ with
branches matching the regular tree expressions
$\mathit{trx}_1\,...\,\mathit{trx}_n$. Whereas regular tree
expressions conventionally allow choice, we encode it using multiple
rules, making the pattern language simpler.

Patterns $p$ are defined inductively as:
\begin{Table}
pattern $p$ &$::=$& $\PVarA$ & pattern variable \\
  &$|$& $\Node{C}{p_1 ... p_n}$ & \Sc{ast} node \\
  &$|$& $[p_1 \dd p_n]$ & list of length $n$ \\
  &$|$& $[p_1 \dd p_n\,\Ell{p}]$ & list of length $\geq n$ \\
  &$|$& $\Value$ & primitive value \\
  &$|$& $\Refn[i]{x}$ $|$ $\Decl[i]{x}$  & variable \\
\end{Table}
In essence, a pattern is a term that can contain pattern variables
$\PVarA$. However, it is very convenient to also allow
\emph{ellipses}, which denote zero or more repetitions of the pattern
they follow. (We formally write ellipses patterns as $\Ell{p}$ to
distinguish them from metasyntactic ellipses).\marginpar{%
  Technically, ellipses do not add any power to pattern-based
  desugaring rules, because they are already Turing complete CITE.
  However, they are very convenient.
}
%% To simplify the formalism, we assume that every ellipsis is given a
%% \emph{label} $l$, such that ellipses that share pattern variables have
%% the same label (and thus must, e.g., be repeated the same number of
%% times). Our implementation does not require these labels, however.
%% Instead, it automatically derives them, and raises an error in the
%% cases where they cannot be sensibly derived.

\section{Matching, Substitution, and Unification}

Our transformations are implemented with simpler operations on patterns:
matching and substitution.

\emph{Matching} a term against a pattern induces an \emph{environment}
that binds the pattern's variables. This environment may be
\emph{substituted} into a pattern to produce another term. Formally, an
environment is a mapping from pattern variables $\PVarA$ to bindings $b$,
where each \emph{binding} is either a term $e$, a \emph{list binding}
$\BList{b_1...b_n}$, or an \emph{ellipsis binding}
$\BList{b_1...b_n\ \Ell{b_e}}$. A pattern variable within ellipses is
bound to a list binding $\BList{b_1...b_n}$ instead of a list term
$[b_1...b_n]$; they behave slightly differently under
substitution. Ellipsis bindings are similar, but needed only during
unification when a variable within an ellipsis is itself bound to an
ellipsis pattern.

We will write $\Match{e}{p}$ to denote matching a term $e$ against a
pattern $p$, and write $\Subs{\gamma}{p}$ to denote substituting the
bindings of an environment $\gamma$ into a pattern $p$.  We will write
$e \geq p$ to mean that $\Match{e}{p}$ is defined, and $\gamma_1 \cup
\gamma_2$ for the \emph{right-biased} union of $\gamma_1$ and
$\gamma_2$. The matching and substitution algorithms are given in
\ref{fig:formal-subs}, while bindings are defined in
\ref{fig:formal-bind}.

\begin{figure}[t]
\[\begin{array}{lcll}
b &:=& e                &\text{(term)} \\
  &|&  \BList{b_1\,...\,b_n}  &\text{(list binding)} \\
  &|&  \BList{b_1\,...\,b_n\,\Ell{b_e}} &\text{(ellipsis binding)} \\ \\
\gamma &:=& \{\PVarA \to b,\,...\} \\
\end{array}\]
\caption{Bindings}
\label{fig:formal-bind}
\end{figure}

\begin{figure*}[t]
\[\begin{array}{lclll}
\Match{\Value}{\Value} &=& \{\} \\
\Match{e}{\PVarA} &=& \{\PVarA \to e\} \\
\Match{[e_1 \dd e_n]}{[p_1 \dd p_n]} &=&
  \bigcup_{i=1..n} (\Match{e_i}{p_i}) \\
\Match{[e_1 \dd e_n \dd e_{n+k}]}{[p_1 \dd p_n \Ell{p_e}]} &=&
  \bigcup_{i=1..n} (\Match{e_i}{p_i}) \cup
  merge([\Match{e_{n+i}}{p_e}]_{i=1..k}) \\
\Match{\Node{C}{e_1 \dd e_n}}{\Node{C}{p_1 \dd p_n}} &=&
  \bigcup_{i=1..n} (\Match{e_i}{p_i}) \\ \\

\Subs{\gamma}{\Value}        &=& \Value \\
\Subs{\gamma}{[p_1 \dd p_n]}    &=& [\Subs{\gamma}{p_1} \dd \Subs{\gamma}{p_n}) \\
\Subs{\gamma}{[p_1 \dd p_n \Ell{p_e}]} &=&
  [\Subs{\gamma}{p_1} \dd \Subs{\gamma}{p_n\,\DoublePlus\,split(\gamma, p_e)} \\
    &&\text{(where } \DoublePlus \text{ is concatenation)} \\
\{\dd,\PVarA \to b,\dd\}\,\PVarA &=& toTerm(b) \\
\Subs{\gamma}{\Node{C}{p_1 \dd p_n}} &=&
  \Node{C}{\Subs{\gamma}{p_1} \dd \Subs{\gamma}{p_n}} \\ \\

\multicolumn{3}{l}{merge([\{\PVarA_1 \to b_1,...\} \dd \{\PVarA_n \to b_n,...\}])} \\
\multicolumn{3}{l}{\quad=\quad \{\PVarA_1 \to \BList{b_1 \dd b_n},\,...\}} \\ \\

\multicolumn{3}{l}{split(\{\PVarA_1 \to \BList{b_{11} \dd b_{1k}} \dd 
  \PVarA_n \to \BList{b_{n1} \dd b_{nk}}\}, p)} \\
\multicolumn{3}{l}{\quad=\quad
  (\Subs{\{\PVarA_1 \to b_{11} \dd  \PVarA_n \to b_{n1}\}}{p} \dd 
   \Subs{\{\PVarA_1 \to b_{1k} \dd  \PVarA_n \to b_{nk}\}}{p})} \\ \\

toTerm(P) &=& P \\
toTerm(\BList{b_1 \dd b_n}) &=&
  (toTerm(b_1) \dd toTerm(b_n))

\end{array}\]
\caption{Matching and substitution}
\label{fig:formal-subs}
\end{figure*}


%% For an example of matching and substitution, consider one of the rules of
%% our running \Code{Or} example:
%% \begin{Codes}
%% Or([x y ys ...] ->
%%   Let([Binding("t" x)]
%%       If(Id("t") Id("t") Or([y ys ...])));
%% \end{Codes}
%% Matching \Code{Or([true Not(true) false true])}
%% against \\ \Code{Or([x y ys ...])}
%% produces the environment
%% \[\gamma = \{
%%    \PVarA \to \Code{true},\
%%    \PVarB \to \Code{Not(true)},\
%%    \PVarC \to \BList{\Code{false}\ \Code{true}}\}\]
%% and substituting $\gamma$ into the rule's \Sc{rhs} produces
%% \begin{Codes}
%% Let([Binding("t" true)]
%%     If(Id("t") Id("t") Or([Not(true) false true])))
%% \end{Codes}

Later, we will need to compute unifications as well. We omit showing the
algorithm; it is straightforward since we disallow duplicate variables (as
seen in the next section).



\section{Desugaring}\label{sec:formal-desugar}

[FILL: desugaring definition]\marginpar{
  Formally, this desugaring definition is a term rewriting system (\Sc{trs})~\cite{trs}. We call
  the \Sc{trs}'s variables \emph{pattern variables} to avoid confusing them
  with references and declarations, which are constants from the
  perspective of the TRS.}


\subsection{Restrictions on Desugaring}\label{sec:formal-reqs}

Not every syntactically valid desugaring rule is semantically
sensible, and not every semantically sensible desugaring rule is
feasible to resugar. Here we give (i) a set of well-formedness
criteria on desugaring rules, without which they don't make semantic
sense, and (ii) a set of restrictions on desugaring rules that we need
to effectively resugar them. The resugaring techniques described in
[REF] will rely on these restrictions.

\paragraph{Well-formedness Criteria for Desugaring Rules}
\begin{enumerate}
\item \emph{Each pattern variable in the \Sc{rhs} also appears in the
  \Sc{lhs}.} Otherwise the pattern variable would be unbound during
  expansion.
\item \emph{An ellipsis of depth $n$ must contain at least one pattern
  variable that appears at depth $n$ on the other side of the rule.}
  Otherwise it is impossible to know how many times to repeat its
  pattern during substitution. (The \emph{depth} of an ellipsis
  measures how deeply nested it is within other ellipses; a top-level
  ellipsis has depth 1, an ellipsis within an ellipsis depth 2, and so
  forth.)
\item $p$ contains no references or declarations. Rather, these
  should be contained in its pattern variables during expansion.
\end{enumerate}

\paragraph{Restrictions on Desugaring Rules}
\begin{enumerate}
\item \emph{Each patern variable appears exactly once in the \Sc{lhs}
  and exactly once in the \Sc{rhs}.}
  Allowing duplicate pattern variables complicates matching,
  unification, and proofs of correctness. It also copies code and, in
  the worst case, can exponentially blow up programs.  We therefore
  disallow duplication, with the sole exception of pattern variables
  bound to atomic terms. [TODO: impl]
  
  Likewise, dropping pattern variables complicates running desugaring
  rules in reverse, which we will need to do in [REF]. (Naively, when
  running a desugaring rule in reverse, a pattern variable that
  appeared on the \Sc{lhs} but not on the \Sc{rhs} would be unbound.)
\item \emph{Each transformation's \Sc{lhs} must have the form
  $\Node{C}{e_1,\,...,\,e_n}$.} We will rely on this fact when showing that
  unexpansion is an inverse of expansion in \cref{sec:reval-inverses}.
\item References and declarations in the \Sc{rhs} are given fresh names during
  expansion to ensure hygiene.
\end{enumerate}

In addition, we have one extra restriction for scope resugaring, and
one for type resugaring.
When resugaring \emph{scope rules} (\cref{chap:resugar-scope}),
desugaring rules may not contain lists or ellipses.
When resugaring \emph{type rules} (\cref{chap:resugar-types}), we will also
require that desugaring rules be disjoint: that is, no two rules can
have \Sc{lhs}s that can be unified.
