\chapter{Resugaring Types}\label{chap:resugar-types}

TODO
\begin{itemize}
\item Proofread: Discussion and conclusion, second paragraph.
\item Proofread: First ~3 paragraphs of introduction.
\item Proofread: 'Type Resugaring', first couple sentences.
\item Proofread: last sentence of 'work with similar goals'.
\end{itemize}

% Formatting specific to this chapter
\newcommand{\reflem}[1]{lemma \ref{lemma:rtype-#1} (#1)}
\newcommand{\Reflem}[1]{Lemma \ref{lemma:rtype-#1} (#1)}
\newcommand{\refass}[1]{assumption \ref{assumption:rtype-#1} (#1)}
\newcommand{\Refass}[1]{Assumption \ref{assumption:rtype-#1} (#1)}


Type systems and syntactic sugar are both valuable to programmers, but
sometimes at odds. While sugar is a valuable mechanism for
implementing realistic languages, the expansion process obscures
program source structure. As a result, type errors can reference terms
the programmers did not write (and even constructs they do not know),
baffling them. The language developer must also manually construct
type rules for the sugars, to give a typed account of the surface
language. In this chapter, we address these problems by presenting a
process for automatically reconstructing type rules for the surface
language using rules for the core. We have implemented this theory,
and show several interesting case studies.

This chapter comes from work published in PLDI 2018 under the
title \emph{Inferring Type Rules for Syntactic Sugar}[CITE: to appear].

\section{Introduction}

While both desugaring and type checking are valuable, they typically
interact poorly. Type checking occurs either before or after
desugaring, and there can be major problems with each.

Suppose type-checking occurs on the desugared code. This has the
virtue of keeping the type-checker's target language more
tractable. However, errors are now going to be generated in terms of
desugared code, and it is not always clear how to report these in
terms of the surface language. This is further complicated when the
code violates implicit type assumptions made by the sugar. In
addition, it requires extra work (that does not correspond to the
implementation of the type-checker) to provide a typed account of the
surface language, which is what the programmer needs to see.

Alternatively, suppose we type-check surface code. This too has two
problems. First, it turns syntactic sugar into a burden by
forcing the type-checker to expand with the size of the surface
language. This is especially problematic in languages with macro-like
facilities, because the macro author must now also know how to extend
a type-checker. This destroys a valuable division of labor: macro
authors may be experts in a domain but not in programming language
theory.  Furthermore, the enlarged type-checker must respect
desugaring: i.e., every program must type in exactly the same way in
the surface as it would have after desugaring.

\paragraph{Inferring a Surface Type System}

We offer a way out of this dilemma. Given typing rules for the core
language, and syntactic sugar written as pattern-based rules, we show
how to \emph{infer} type rules for the surface language.

Notice that this is not a \emph{complete} solution to the problem: we
provide type rules, but not a full type checker with quality error
messages. This could be done automatically or manually.
Automatically extending a type checker while maintaining good error
messages is (we believe) an open, and independently valuable, problem.
Alternatively, the type rules can (as usual) be added to the type
checker by hand.

Whichever method is used, these new rules can be
added to the documentation for the language, providing a typed account
of the surface. These rules are also a useful \emph{diagnostic},
enabling the author of the sugar, or an expert on the language's
types, to confirm that the inferred typing rules are expected; when
they are not, these suggest a flaw in the desugaring. This diagnostic
comes very early in the pipeline: it relies only on the sugar
\emph{definition}, and so is available before a sugar is ever used.

This approach depends crucially on a particular guarantee, which our
system will provide:
\begin{quotation}
  A surface program has a type in the inferred surface type
  system iff its desugaring has that type in the core type system.
\end{quotation}
Thus, a well-typed program under the inferred surface rules
will desugar into a well-typed program under the original core rules.
As a result, an ill-typed program will always be caught in the surface
type system, and an ill-typed sugar will be rejected by our
algorithm \emph{at definition time} rather than having to wait until
it is used. Since the inferred type rules are guaranteed to be correct,
they become a valid documentation of the
surface language's type structure.

\section{Type Resugaring} \label{sec:rtype-walkthrough}

Our overall aim is to be able to generate type judgments for the
surface language given desugaring rules and judgments for the core.
i.e., to perform \emph{type resugaring}. Type resugaring, in which
\emph{type rules} are inferred \emph{through syntactic sugar},
should be distinguished from ordinary type
inference, in which \emph{types} are inferred \emph{within a program}.
We wish to obtain type rules for the surface
language that are faithful to the core language type rules:
type checking using resugared type rules should produce
the same result as first desugaring and then type checking using the
core type rules.
Specifically, if $\overline{\Icore}$ are the core language type rules and
$\overline{\Isurf}$ are the resugared surface type rules, then
\begin{goal} \label{goal:rtype-faithful}
\[
\saysJ{\overline{\Isurf}}{\saysT{\Gamma}{e}{t}}
\Iff
\saysJ{\overline{\Icore}}{\saysT{\Gamma}{\Desugar{e}}{t}}
\]
\end{goal}
\noindent
where $\saysJ{\overline{I}}{J}$ means that judgment $J$ is provable by
inference rules $\overline{I}$, and $\Desugar{e}$ means the desugaring
of expression $e$.

Notice the assumption implicit in this equation: the right-hand-side
says $t$, rather than $\Desugar{t}$. We are handling desugaring of
expressions, but not of types. It is sometimes desirable to introduce
a new type by way of translation into an existing type: for instance,
introducing Booleans and implementing them in terms of Integers.
We leave this to future work.

To see how type resugaring might proceed, let us work through an
example. Take a simple \Code{and} sugar, defined by:
\[
\DesugarRule{$\alpha$ and $\beta$}{if $\alpha$ then $\beta$ else false}
\]

\newcommand{\tandr}{\texttt{t-and$^\rightarrow$}}
\newcommand{\tandl}{\texttt{t-and$^\leftarrow$}}
Our goal is to construct a type rule for \Code{and} that is faithful
to the core language, meaning that (using \cref{goal:rtype-faithful}):
\begin{Table}
  &&    $\saysJ{\overline{\Isurf}}{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{t}}$ \\
  &iff& $\saysJ{\overline{\Icore}}{\saysT{\Gamma}{\Desugar{\texttt{$\alpha$ and $\beta$}}}\texttt{t}}$
\end{Table}
Expanding out the sugar:
\begin{Table}
&&    $\saysJ{\overline{\Isurf}}{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{t}}$ \\
&iff& $\saysJ{\overline{\Icore}}{\saysTt{\Gamma}{(if $\Desugar{\alpha}$ then $\Desugar{\beta}$ else false)}{t}}$
\end{Table}
It is seemingly straightforward to obtain this property. We just have to add this
inference rule to $\overline{\Isurf}$:
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{(if $\Desugar{\alpha}$ then $\Desugar{\beta}$ else false)}{t}}
  \ROne[\tandr]{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{t}}
\end{prooftree}
and perhaps also its converse:
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{t}}
  \ROne[\tandl]{\saysTt{\Gamma}{(if $\Desugar{\alpha}$ then $\Desugar{\beta}$ else false)}{t}}
\end{prooftree}
The rule \tandr can be read as ``to prove that
\texttt{($\alpha$ and $\beta$)} has type $t$ under type environment
$\Gamma$ in the surface language, prove that its desugaring has type
$t$ under $\Gamma$ in the core language''. This is useful because it
provides a way to prove a type in the surface language by way of the
core language type rules.

Its converse \tandl, however, is not helpful: there is no need to use the
surface language when trying to prove a type in the core
language. Furthermore, \tandl is actually redundant: since
\tandr is the only type rule mentioning \Code{and}, \tandl
is admissible. Therefore, we only need \tandr.

In this particular case, we have added only the rule \tandr,
but in general we would add one such rule for each sugar. This could
be called the \emph{augmented} type system: it is the core language
type system, plus one extra rule per sugar, such that we obtain a type
system for the surface language.

Type checking in this augmented type system is akin to desugaring the
program and type checking in the core language. For example, the
program \Code{true and false} has the type derivation:
\begin{prooftree} % Squeezing this is much better for readability than any of the alternatives.
  \RZero{}
  \ROne{\squeeze{0.3em}{\saysTt{}{true}{Bool}}}
  \RZero{}
  \ROne{\squeeze{0.3em}{\saysTt{}{false}{Bool}}}
  \RZero{}
  \ROne{\squeeze{0.3em}{\saysTt{}{false}{Bool}}}
  \RThree[t-if]{\saysTt{}{(if true then false else false)}{Bool}}
  \ROne[\tandr]{\saysTt{}{(true and false)}{Bool}}
\end{prooftree}

Since the extension
type rules (like \tandr) always succeed, any type errors will
be found in the core language. For example, if the first argument to
\Code{and} was not a boolean, this will be discovered by the \texttt{t-if}
rule, not by the \tandr rule! Thus, while the augmented type
system technically obeys \cref{goal:rtype-faithful}, it breaks the
abstraction that ought to be provided by syntactic sugar. Type errors
made in the surface language should be reported with respect to
surface language constructs. This can be achieved with a second
goal:
\begin{goal} \label{goal:rtype-abstraction}
  Type rules for surface constructs should not mention core constructs.
\end{goal}
Let us see how we can accomplish this.
The essential insight is that every type derivation of
\Code{and} will share a common form. It will always follow the
template:
\begin{prooftree}
  \RZero{D_\alpha}
  \ROne{\squeeze{0.5em}{\saysTt{\Gamma}{$\alpha$}{Bool}}}
  \RZero{D_\beta}
  \ROne{\squeeze{0.5em}{\saysTt{\Gamma}{$\beta$}{Bool}}}
  \RZero{}
  \ROne[t-false]{\squeeze{0.2em}{\saysTt{\Gamma}{false}{Bool}}}
  \RThree[t-if]{\saysTt{\Gamma}{(if $\alpha$ then $\beta$ else false)}{Bool}}
  \ROne[\tandr]{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{Bool}}
\end{prooftree}
where the sub-derivations $D_\alpha$ and $D_\beta$ depend on $\alpha$
and $\beta$. Notice that the rest of the derivation is constant:
\emph{every} type-derivation of \Code{$\alpha$ and $\beta$} has this
form. Thus there is no reason to re-derive it every time we
type-check. Instead, we can remove this ``cruft'' to obtain a simpler
type rule for \Code{and}:
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{$\alpha$}{Bool}}
  \RZero{\saysTt{\Gamma}{$\beta$}{Bool}}
  \RTwo[t-and]{\saysTt{\Gamma}{($\alpha$ and $\beta$)}{Bool}}
\end{prooftree}
This type rule now satisfies our two goals, and is a valid and useful
type rule for the surface language. Indeed, it hides the
implementation of \Code{and} and instead focuses just on its
(expected) type structure.

The important step was determining the ``template'' derivation. We
presented it above without fanfare, but how can it automatically be
discovered? Let us look into this with a slightly more
complex example, an \Code{or} sugar\marginpar{%
The \Code{let} in the desugaring of \Code{or} prevents the
  duplicate evaluation of $\alpha$.}:
\[\DesugarRule
  {$\alpha$ or $\beta$}
  {let x = $\alpha$ in if x then x else $\beta$}\]
As before, we want to find a derivation for the sugar's
\Sc{rhs} (right-hand-side). That is, we should search for a derivation of the
judgment:
\[ \saysTt{\Gamma}{(let x = $\alpha$ in if x then x else $\beta$)}{t} \]
We can begin by applying the core type rules, obtaining a partial derivation,
shown at the top of \cref{fig:rtype-or}. However, the core type rules
(unsurprisingly) cannot prove the judgments about pattern variables
(marked with {\qmark}). Each pattern variable stands for an unknown
surface term, so its derivation will vary between different uses
of the \Code{or} sugar. Since we do not know what type it will have,
we will assign it a globally fresh type variable, using the rule \Code{t-premise}:
\begin{prooftree}
  \RZero{\text{fresh } x}
  \dashedLine\ROne[t-premise]{\saysT{\Gamma}{\alpha}{x}}
\end{prooftree}
(This rule will be generalized in \cref{sec:rtype-recursion} and
\cref{sec:rtype-fresh}.) We write this rule with a dashed line because it is
in a sense incomplete: it serves as a placeholder for a subderivation
that would be filled in if the pattern variable were instantiated.
Using this rule finishes the derivation, giving the bottom derivation
in \cref{fig:rtype-or}.

\begin{figure*}[t]
  \begin{Wide}
    \small
  \raggedright
%An incomplete derivation for \Code{or}:
\begin{prooftree}
  \RZero{{\qmark}}
  \ROne{\saysTtt{\Gamma}{$\alpha$}{A}}
  \RZero{}
  \ROne[t-id]{\saysTtt{\Gamma,x:A}{x}{A}}
  \RZero{\squeeze{0.5em}{A = \texttt{Bool}}}
  \RZero{}
  \ROne[t-id]{\saysTtt{\Gamma,x:A}{x}{A}}
  \RZero{{\qmark}}
  \ROne{\saysTtt{\Gamma,x:A}{$\beta$}{B}}
  \RZero{\squeeze{0.5em}{A = B}}
  \RFive[t-if]{\saysTtt{\Gamma,x:A}{if x then x else $\beta$}{B}}
  \RTwo[t-let]{\saysTtt{\Gamma}{let x = $\alpha$ in if x then x else $\beta$}{B}}
%  \ROne[t-or$^\rightarrow$]{\saysTtt{\Gamma}{$\alpha$ or $\beta$}{B}}
\end{prooftree}

%A complete derivation for \Code{or}, using \Code{t-premise}:
\begin{prooftree}
  \RZero{}
  \dashedLine\ROne[t-prem.]{\squeeze{0.5em}{\saysTtt{\Gamma}{$\alpha$}{A}}}
  \RZero{}
  \ROne[t-id]{\saysTtt{\Gamma,x:A}{x}{A}}
  \RZero{\squeeze{1em}{A = \texttt{Bool}}}
  \RZero{}
  \ROne[t-id]{\saysTtt{\Gamma,x:A}{x}{A}}
  \RZero{}
  \dashedLine\ROne[t-prem.]{\squeeze{0.5em}{\saysTtt{\Gamma,x:A}{$\beta$}{B}}}
  \RZero{\squeeze{1em}{A = B}}
  \RFive[t-if]{\saysTtt{\Gamma,x:A}{if x then x else $\beta$}{B}}
  \RTwo[t-let]{\saysTtt{\Gamma}{let x = $\alpha$ in if x then x else $\beta$}{B}}
\end{prooftree}
\caption{Derivation of \Code{or}.
  Top: an incomplete derivation.
  Bottom: a complete derivation, using \Code{t-premise}.
}
\end{Wide}
\label{fig:rtype-or}
\end{figure*}

As seen, pattern variables introduce type variables. Solving for these
type variables in general requires unification.
We therefore split the search for a derivation: first
we find a potential derivation with equality constraints (as in
\cref{fig:rtype-or}), then we solve these constraints (via an ordinary
unification algorithm). Solving the constraints of \cref{fig:rtype-or} gives
the substitution $\{ A=\Code{Bool},\,B=\Code{Bool} \}$.
Finally, gathering the premises and conclusion of the derivation
and applying the substitution to them produces the type rule for
\Code{or}:
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{$\alpha$}{Bool}}
  \RZero{\saysTt{\Gamma}{$\beta$}{Bool}}
  \RTwo[t-or]{\saysTt{\Gamma}{$\alpha$ or $\beta$}{Bool}}
\end{prooftree}

\paragraph{Our Overall Approach}
Putting all this together, we can describe our type resugaring
algorithm.
For each desugaring rule, such as the \Code{or} sugar from above:
\begin{enumerate}
  \item Construct a generic type judgment from the sugar's
    \Sc{rhs},\\ % NEWLINE
    e.g. $\saysTtt{\Gamma}{(let x = $\alpha$ in if x then x else $\beta$)}{t}$
  \item Search for a derivation of this judgment using the core
    language type rules
    plus the \Code{t-premise} rule from above. Fail if no derivation,
    or if multiple derivations, are found. For example, this will
    find the derivation shown in \cref{fig:rtype-or}.
  \item Gather the equality constraints from the derivation.
    Additionally, if multiple premises (i.e., judgments proved by the
    \Code{t-premise} rule) are of the same expression, add equality
    constraints that these expressions have the same type. Solve the
    unification problem. (If there are any unconstrained variables,
    they become free variables in the type rule.)

    For example, in \Code{or}, there are two equality constraints:
    $A = \Code{Bool}$ and $A = B$. The
    \Code{t-premise} rule is used only once for $\alpha$ and once for
    $\beta$, so no additional constraints are needed. The solution is
    $\{A = \Code{Bool},\,B=\Code{Bool}\}$.
  \item Form a type rule whose premises are the judgments proved by
    \Code{t-premise} from the derivation in step (2), and whose
    conclusion is a generic type judgment from the sugar's \Sc{lhs}.
    Apply the unification from step (3). This is the resugared surface %
    type rule.
\end{enumerate}

We have implemented a prototype of this approach, called SweetT.
SweetT is written in Racket~\cite{plt-tr1} (\url{racket-lang.org}),
and makes use of the semantics engineering tool Redex~\cite{redex}.
\emph{All of the examples in this chapter run in SweetT},
albeit with a different, more parenthetical, syntax.


\section{Theory}

In this section, we describe the assumptions that type resugaring will
rely on, and then prove that it obeys
\cref{goal:rtype-faithful} and \cref{goal:rtype-abstraction} given these assumptions.
Roughly speaking, these assumptions are:
\begin{itemize}
  \item Desugaring rules must be defined using pattern-based rules,
    and their \Sc{lhs}s must be disjoint (\cref{sec:rtype-req-desugar}).
  \item The type system used
    to resugar must support pattern variables and partial
    derivations, and they must obey obvious laws (\cref{sec:rtype-req-type}).
  \item The core language type rules must be syntax directed
    (also \cref{sec:rtype-req-type}). This will fail, for instance, on a
    type system with non-algorithmic subtyping.
  \item Our implementation of SweetT must be correct
    (\cref{sec:rtype-req-resugar}). (As must Redex, which we use to find
    derivations.)
  \item Finally, SweetT's unification algorithm must be able to handle
    the sugars given. \cref{sec:rtype-arity} gives an example of extending it.
\end{itemize}

The rest of this section describes these assumptions in more
detail. As a prelude, \cref{fig:rtype-notation} provides a guide to the
notation we will use throughout the chapter.

\begin{figure}\InABox{
  \paragraph{Notation Explanation}
  \begin{Table}
    $e$ &$::=$& $\Value$
    & (primitive value) \\
        &$|$&  $(P\,\seq{e})$
    & (compound expression \\
    &&& of syntactic category $P$) \\
    $p$ &$::=$& $\Value$ \\
      &$|$&   $(P\,\seq{e})$ \\
        &$|$&   $\alpha$
    & (pattern variable) \\
    $t$ &$::=$& $type$
    & (type) \\
    $\Gamma$ &$::=$& $\cdot$ $|$ $\Gamma,\,x:t$
    & (type environment) \\
    $J$ &$::=$& $\saysT{\Gamma}{p}{t}$
    & (type judgment) \\
    $I$ &$::=$& $\seq{J} / J$
    & (inference rule) \\
    $\overline{I}$ &$::=$& $\seq{I}$
    & (set of inference rules) \\
    $\gamma$ &$::=$& $\{\alpha \to e,\,\dots\}$
    & (substitution) \\
    $\Lang$ &$::=$& $\{p \To p',\,\dots\}$
    & (desugaring rules)
  \end{Table}
  Our approach relies on being able to use $p$ in two different
  ways: (i) from one perspective $p$ is one side of a syntactic
  sugar rule, and any $\alpha$ inside is a pattern variable; (ii) from
  the other perspective, $p$ is an expression inside a type
  rule, in which $\alpha$ is a metavariable. The convention of the
  first perspective is to call $p$ as $C$, but we choose
  instead to use $p$ to emphasize the other perspective.

  In addition, to the above notation, we will also write:
  \begin{description}
  \item[$\saysJ{\overline{I}}{J}$] to mean that judgment $J$ is
    provable under inference rules $\overline{I}$ (i.e., there is a
    derivation that proves $J$).
  \item[$\saysVD{\overline{I}}{\seq{J}}{J}$] to mean that there is a
    derivation that proves $J$ with unproven leaves $J_i$.
  \item[$(\Subs{\gamma}{p})$] to denote applying substitution $\gamma$
    to expression $p$. To substitute into a
    type judgment, substitute into its parts (likewise for type environments):
    \[\Subs{\gamma}{(\saysT{\Gamma}{p}{t})} \quad=\quad
      \saysT{(\Subs{\gamma}{\Gamma})}{(\Subs{\gamma}{p})}{(\Subs{\gamma}{t})} \]
  \end{description}
}\caption{Notation explanation}
\label{fig:rtype-notation}  
\end{figure}




\subsection{Requirements on Desugaring}\label{sec:rtype-req-desugar}

First, we require that desugaring rules be pattern-based.
Each desugaring rule has a \Sc{lhs} and a \Sc{rhs}, which
are terms $p$ that may contain pattern variables. Desugaring proceeds
by recursively expanding these rules, replacing the \Sc{lhs}
with the \Sc{rhs}. Formally:
\begin{Table}
  $\Desugar{\Value}$
  &$=$& $\Value$ \\
  $\Desugar{\Subs{\gamma}{p}}$
  &$=$& $\Subs{(\Desugar{\gamma})}{(\Lang[p])}$ \\
  && if $p$ is in the surface language \\
  $\Desugar{P\,\seq{e}}$
  &$=$& $(P\,\Desugar{e_1}\dots\Desugar{e_n})$ \\
  && if $P$ is in the core language \\
\end{Table}
where $\Desugar{\cdot}$ is desugaring, $\Lang$ represents the
desugaring rules, $\Lang[p]$ is the \Sc{rhs} of the desugaring
rule whose \Sc{lhs} is $p$, and desugaring a substitution
$\gamma$ means desugaring its expressions: $\Desugar{\{\alpha \mapsto
  e, ...\}} = \{\alpha \mapsto \Desugar{e}, ...\}$.

Likewise, desugaring can be extended in the obvious way to desugar
judgements and type environments:
\begin{Table}
  $\Desugar{\saysT{\Gamma}{p}{t}}$
  &$=$& $\saysT{\Gamma}{\Desugar{p}}{t}$ \\
  $\Desugar{\{x \to p, \dots\}}$
  &$=$& $\{x \to \Desugar{p}, \dots\}$
\end{Table}

Unsurprisingly, substitution distributes over pattern-based desugaring:
\begin{lemma}[Distributivity of Substitution and Desugaring]
  \label{lemma:rtype-distributivity}
  \[\Desugar{\Subs{\gamma}{J}} = \Subs{\Desugar{\gamma}}{\Desugar{J}}\]
\end{lemma}
\begin{proof}
  Let $J = \saysT{\Gamma}{p}{t}$.
  By definition, $\Desugar{\saysT{\Gamma}{p}{t}} = \saysT{\Gamma}{\Desugar{p}}{t}$.
  Induct on $p$.

  \textit{Base case: $e$ is a primitive value}:\\
  $\Desugar{\Subs{\gamma}{\Value}} = \Value = \Subs{\Desugar{\gamma}}{\Value}$.

  \textit{Base case: $e$ is a pattern variable $\alpha$}:\\
  $\Desugar{\Subs{\gamma}{\alpha}}
  = \Desugar{\gamma[\alpha]}
  = (\Desugar{\gamma})[\alpha]
  = \Subs{\Desugar{\gamma}}{\alpha}
  = \Subs{\Desugar{\gamma}}{\Desugar{\alpha}}$.

  \textit{Inductive case: $e$ is a compound term
    $\Subs{\{\alpha_1 \mapsto e_1, ...\}}{p}$}:\\
  \begin{Table}
    && $\Desugar{\Subs{\gamma}{(\Subs{\{\alpha_1 \mapsto e_1, ...\}}{p})}}$ \\
    &=& $\Desugar{\Subs{\{\alpha_1 \mapsto (\Subs{\gamma}{e_1}), ...\}}{p}}$
    & (substitution) \\
    &=& $\Subs{\{\alpha_1 \mapsto \Desugar{\Subs{\gamma}{e_1}}, ...\}}{p'}$
    & where $\mathcal{L}[p] = p'$ \\
    &=& $\Subs{\{\alpha_1 \mapsto (\Subs{\Desugar{\gamma}}{\Desugar{e_1}}), ...\}}{p'}$
    & (I.H.) \\
    &=& $\Subs{\Desugar{\gamma}}{(\Subs{\{\alpha_1 \mapsto \Desugar{e_1}, ...\}}{p'})}$
    & (substitution) \\
    &=& $\Subs{\Desugar{\gamma}}{\Desugar{\Subs{\{\alpha_1 \mapsto e_1, ...\}}{p}}}$
    & (desugar)
  \end{Table}
\end{proof}

We also assume that the \Sc{lhs}s of each desugaring rule are
disjoint, so that there is never any ambiguity as to which resugaring
rule to apply. That is:
\begin{assumption}[Unique Desugaring]\label{assumption:rtype-unique-sugar}
  For every pair $p_1$ and $p_2$ of sugar \Sc{lhs}s, there are no
  substitutions $\gamma_1$ and $\gamma_2$ such that
  $\Subs{\gamma_1}{p_1} = \Subs{\gamma_2}{p_2}$.
\end{assumption}
This is everything we need of desugaring.

\subsection{Requirements on the Type System}\label{sec:rtype-req-type}

Let us now change focus to the type system.
In the \Code{and} example in \cref{sec:rtype-walkthrough}, we made implicit
assumptions about the core type system. We stated that \emph{every} type
derivation of \Code{($\alpha$ and $\beta$)} must share a common template,
and we implicitly assumed that this template could not depend on
$\alpha$ or on $\beta$.
This is certainly not true of every conceivable type system.
Type resugaring will rely on three assumptions about the
type system in order to make the approach we outlined work.

Before we describe these assumptions, notice that the type derivations
found by resugaring (e.g., in \cref{fig:rtype-or}) contain pattern
variables. Thus the type system used by resugaring is not exactly the
language's type system: it is an extension of the type system that
handles pattern variables (and partial derivations, discussed
shortly). It is this extended type system we will be discussing in
this section. With that said, we can state the assumptions.

First, we will assume that the type system
supports pattern variables: it
must be possible to search for type derivations of a judgment whose
term contains pattern variables. Furthermore, a judgment with pattern
variables must hold iff that judgment holds under all substitutions
for those pattern variables:

\begin{assumption}[Substitution into Derivations]
  \label{assumption:rtype-substitution}
  A derivation (possibly containing pattern variables) is provable iff it is
  provable under all substitutions:
  \[\text{
    $\saysVD{\overline{I}}{\seq{J}[n]}{J}$
    \quad iff \quad $\Forall{\gamma} \saysVD{\overline{I}}{\seq{\Subs{\gamma}{J}}[n]}{\Subs{\gamma}{J}}$
  }\]
  Likewise for rules:
  \[\text{
    $\saysVJ{\overline{I}}{\seq{J}[n]}{J}$
    \quad iff \quad $\Forall{\gamma} \saysVJ{\overline{I}}{\seq{\Subs{\gamma}{J}}[n]}{\Subs{\gamma}{J}}$
  }\]
\end{assumption}

Next, we assume that the type system supports \emph{partial
  derivations} that may contain unjustified judgments in their leaves,
which we will call their \emph{premises}. If a partial derivation is
provable, and its premises are provable, then its conclusion must also
be provable:

\begin{assumption}[Composition of Derivations]
  \label{assumption:rtype-composition}
  The composition of provable derivations is provable: \\
  \[\text{
  If  $\saysVD{\overline{I}}{\seq{J}[n]}{J}$
  and $\Forall{i} \saysJ{\overline{I}}{J_i}$,
  then $\saysJ{\overline{I}}{J}$.
  }\]
\end{assumption}

Finally, we would like the core type system to be
\emph{deterministic} in a particular way.
Say that a judgment is \emph{abstract} if it contains pattern
variables, or \emph{concrete} otherwise.
We would like that if an \emph{abstract} partial derivation
$\seq{J}[n] \to J$ applies to a \emph{concrete}
judgment $\Subs{\gamma}{J}$ that can be proven, then the proof of
$\Subs{\gamma}{J}$ \emph{must} use $\seq{J}[n] \to J$,
and thus prove as intermediate steps $\Subs{\gamma}{J_i}$ for each $i \in 1..n$.
Formally, we define determinism as:

\begin{definition}[Determinism]
  \label{def:rtype-determinism}
  A set of inference rules $\overline{I}$ is \emph{deterministic} when,
  for any concrete judgment $\Subs{\gamma}{J}$:
  
  If $\saysJ{\overline{I}}{\Subs{\gamma}{J}}$
  and $\saysVD{\overline{I}}{\seq{J}[n]}{J}$,
  then $\saysD{\overline{I}}{\Subs{\gamma}{J_i}}$ for each $i \in 1..n$.
\end{definition}

Instead of assuming outright that the core language is deterministic,
we can prove it from a more conservative assumption. We will assume
that there is never any ambiguity
as to which type rule applies to a concrete judgment $J$, i.e., that
the type system is syntax directed:

\begin{assumption}[Syntax Directedness]
  \label{assumption:rtype-unique-rule}
  At most one type rule in $\overline{\Icore}$ ever applies to a concrete
  judgment $J$.
\end{assumption}

Under this assumption, the core language can be proven
deterministic. This will be essential for our proof of
\cref{goal:rtype-faithful}.

\begin{lemma}[Determinism]
  \label{lemma:rtype-determinism}
  Suppose that at most one type rule in $\overline{I}$ ever applies to a
  concrete judgment $J$.
  Then $\overline{I}$ is deterministic.
\end{lemma}
\begin{proof}
  Suppose that 
  $\saysJ{\overline{I}}{\Subs{\gamma}{J}}$
  and $\saysVD{\overline{I}}{\seq{J}[n]}{J}$.
  We aim to show that $\saysD{\overline{I}}{\Subs{\gamma}{J_i}}$ for each $i \in 1..n$.
  
  Induct on the derivation
  $\saysVD{\overline{I}}{\seq{J}[n]}{J}$.
  Let the bottommost step in the derivation be
  $\saysVJ{\overline{I}}{J_1' \dots J_m'}{J}$, and call this rule $R$.
  By \refass{substitution}, \newline
  $\saysVJ{\overline{I}}{\Subs{\gamma}{J_1'} \dots \Subs{\gamma}{J_m'}}{\Subs{\gamma}{J}}$.
  Since, by \refass{unique-rule}, only one rule can apply to the
  judgment $\Subs{\gamma}{J}$, no rule other than $R$ may apply.
  Hence the derivation of $\Subs{\gamma}{J}$ \emph{must} have
  $\saysVJ{\overline{I}}{\Subs{\gamma}{J_1'} \dots \Subs{\gamma}{J_m'}}{\Subs{\gamma}{J}}$
  as the bottommost step.
  Thus for each $i \in 1..m$:
  \begin{itemize}
  \item $\saysJ{\overline{I}}{\Subs{\gamma}{J'_i}}$, and
  \item There is a subset $\seq[i_1]{J}[i_l]$ of
    $\seq{J}$ such that $\saysVD{\overline{I}}{\seq[i_1]{J}[i_l]}{J'_i}$.
    Since each judgment $\seq{J}$ must be used in the derivation
    $\saysD{\overline{I}}{J}$, the union of these subsets must be
    the full set $\seq{J}$.
  \end{itemize}
  For each $i \in 1..m$, by the inductive hypothesis, \newline
  $\saysJ{\overline{I}}{\seq[i_1]{\Subs{\gamma}{J}}[i_l]}$.
  Since the union of these sets is $\Subs{\gamma}{J_1}\dots\Subs{\gamma}{J_n}$, we are done.

  (Note that in the base case, $n = 0$, and the result is vacuously
  true.)
\end{proof}
\begin{corollary}[Core Determinism]
  \label{lemma:rtype-core-determinism}
  If a core language $\overline{\Icore}$ obeys \refass{unique-rule},
  then it is deterministic.
\end{corollary}
\begin{proof}
  Follows from the lemma, together with \refass{unique-rule}.
\end{proof}
  


\subsection{Requirements on Resugaring}\label{sec:rtype-req-resugar}

Our final set of requirements is on the behavior of the type
resugaring algorithm. Thus it is essentially a specification for our
implementation: {SweetT} is correct iff it obeys the requirements of
this subsection.

Let us look at what it means to successfully resugar a desugaring rule
$p_\Sc{lhs} \To p_\Sc{rhs} \in \Lang$.
Resugaring will search for a partial derivation of the sugar's \Sc{rhs}:
\[ \saysVD{\overline{\Icore}}{\seq{J}}{J_\Sc{rhs}} \]
where $\seq{J}$ are provable using the \Code{t-premise} rule and
$J_\Sc{rhs}$ has the form $J_\Sc{rhs} = \saysT{\Gamma}{p_\Sc{rhs}}{t}$.
If such a derivation is found, and is unique, then we will write:
\[ \ResugarTy{\overline{\Icore}}{p_\Sc{lhs} \To p_\Sc{rhs}}
 = \seq{J} / J_\Sc{lhs} \]
where $J_\Sc{lhs} = \saysT{\Gamma}{p_\Sc{lhs}}{t}$,
and we will add the type rule $\seq{J} / J_\Sc{lhs}$ to $\overline{\Isurf}$. Therefore:

\begin{assumption}[Resugaring]
  \label{assumption:rtype-resugaring}
  Suppose that \newline
  $\ResugarTy{\overline{\Icore}}{p_\Sc{lhs} \To p_\Sc{rhs}}
  = \seq{J} / (\saysT{\Gamma}{p_\Sc{lhs}}{t})$.
  Then:
  \[ \saysVD{\overline{\Icore}}{\seq{J}}{\Desugar{\saysT{\Gamma}{p_\Sc{lhs}}{t}}} \]
\end{assumption}
\noindent
This is the correctness criterion for resugaring.

For the upcoming proof, we will also need that the surface language be
deterministic in the sense of \cref{def:rtype-determinism}. This is provable
using \refass{unique-sugar}:

\begin{lemma}[Surface Determinism]
  \label{lemma:rtype-surface-determinism}
  If resugaring succeeds, then $\Isurf$ is \emph{deterministic}.
  Repeating the definition of determinism, this means that:

  If $\saysJ{\Isurf}{\Subs{\gamma}{J}}$
  and $\saysVD{\Isurf}{\seq{J}[n]}{J}$,
  then $\saysD{\Isurf}{\Subs{\gamma}{J_i}}$ for each $i \in 1..n$.
\end{lemma}
\begin{proof}
  To start, we will show that at most one resugared type rule may
  apply to a concrete judgment $J$. Suppose, for the sake of
  contradiction, that two distinct rules apply, with conclusions $J_1$
  and $J_2$. Let the expressions in $J$, $J_1$, and $J_2$ be $e$,
  $e_1$, and $e_2$ respectively. Since both rules can be applied to
  $J$, there must be substitutions $\gamma_1$ and $\gamma_2$ such that
  $\Subs{\gamma_1}{J_1} = \Subs{\gamma_2}{J_2} = J$. Thus
  $\Subs{\gamma_1}{e_1} = \Subs{\gamma_2}{e_2} = e$. However, this
  contradicts \refass{unique-sugar}. Thus at most one type rule
  in $\Isurf$ may apply to a concrete judgment.

  Then, by \cref{lemma:rtype-determinism}, $\Isurf$ is deterministic.
\end{proof}


\subsection{Main Theorem}

Given the requirements of this section, type resugaring obeys
\cref{goal:rtype-faithful}:
\begin{theorem} \label{thm:rtype-faithful}
  Grant assumptions 1--5 from this section,
  let $\Lang = p_\Sc{lhs}\To_\Sc{rhs}\dots$,
  and suppose that \newline
  $\ResugarTy{\overline{\Icore}}{p_\Sc{lhs}\To_\Sc{rhs}}\dots = \overline{\Isurf}$. Then:

  \[\saysJ{\overline{\Isurf}}{\Jsurf} \text{ iff }
  \saysJ{\overline{\Icore}}{\Desugar{\Jsurf}} \]
\end{theorem}
\begin{proof}
  Given in \cref{fig:rtype-faithful}.
\end{proof}
\begin{figure*}\begin{flushleft}
  \begin{Wide}
  \begin{proof}
  Split on the ``iff''.

  \textbf{Forward implication (``soundness'').}
  Induct on the derivation proving that $\saysJ{\overline{\Isurf}}{\Jsurf}$.
  Let $\seq{J}/J_0 = \ResugarTy{\overline{\Icore}}{\_}$ be the rule in $\Isurf$
  used to prove $\Jsurf$, and let $\gamma$ be the substitution such
  that $\Jsurf = \Subs{\gamma}{J_0}$.
  Then:
  \begin{Table}
    &&
    $\saysJ{\overline{\Isurf}}{\Jsurf}$
    & assumption
    \\
    &iff&
    $\saysJ{\overline{\Isurf}}{\Subs{\gamma}{J_0}}$
    & equality
    \\
    &implies&
    $\saysJ{\overline{\Isurf}}{\Subs{\gamma}{J_i}}$ for $i \in 1..n$
    & by \cref{lemma:rtype-surface-determinism} (surface determinism)
    \\
    &implies&
    $\saysJ{\overline{\Icore}}{\Desugar{\Subs{\gamma}{J_i}}}$ for $i \in 1..n$
    & inductive hypothesis
  \end{Table}

  Also:
  \begin{Table}
    &&
    $\saysVJ{\overline{\Icore}}{\seq{J}[n]}{\Desugar{J_0}}$
    & by \refass{resugaring}
    \\
    &implies&
    $\saysVJ{\overline{\Icore}}
      {\Subs{\Desugar{\gamma}}{J_1}\dots\Subs{\Desugar{\gamma}}{J_n}}
      {\Subs{\Desugar{\gamma}}{\Desugar{J_0}}}$
    & by \refass{substitution}
    \\
    &iff&
    $\saysVJ{\overline{\Icore}}
      {\Subs{\Desugar{\gamma}}{\Desugar{J_1}}\dots\Subs{\Desugar{\gamma}}{\Desugar{J_n}}}
      {\Subs{\Desugar{\gamma}}{\Desugar{J_0}}}$
    & since $\Desugar{J_i} = {J_i}$
    \\
    &iff&
    $\saysVJ{\overline{\Icore}}
      {\Desugar{\Subs{\gamma}{J_1}}\dots\Desugar{\Subs{\gamma}{J_n}}}
      {\Desugar{\Subs{\gamma}{J_0}}}$
    & by \reflem{distributivity}
    \\
    &iff&
    $\saysVJ{\overline{\Icore}}
      {\Desugar{\Subs{\gamma}{J_1}}\dots\Desugar{\Subs{\gamma}{J_n}}}
      {\Desugar{\Jsurf}}$
    & equality
  \end{Table}

  Thus $\saysJ{\overline{\Icore}}{\Desugar{\Jsurf}}$ by \refass{composition}.
  
  \textbf{Reverse implication (``completeness'').}
  Induct on the derivation proving that $\saysJ{\overline{\Icore}}{\Desugar{\Jsurf}}$.
  Let $\seq{J}/J_0 = \ResugarTy{\overline{\Icore}}{\_}$ be the rule in $\overline{\Isurf}$
  for the (outermost) sugar in $\Jsurf$'s expression,
  and let $\gamma$ be the substitution such
  that $\Jsurf = \Subs{\gamma}{J_0}$.
  Then:
  \begin{Table}
    &&
    $\saysJ{\overline{\Icore}}{\Desugar{\Jsurf}}$
    & assumption
    \\
    &iff&
    $\saysJ{\overline{\Icore}}{\Desugar{\Subs{\gamma}{J_0}}}$
    & equality
    \\
    &implies&
    $\saysJ{\overline{\Icore}}{\Subs{\Desugar{\gamma}}{\Desugar{J_0}}}$
    & by \reflem{distributivity}
    \\
    &Also:&
    $\saysVD{\overline{\Icore}}{\seq{J}[n]}{\Desugar{J_0}}$
    & by \refass{resugaring}
    \\
    &implies&
    $\saysJ{\overline{\Icore}}{\Subs{\Desugar{\gamma}}{J_1}\dots\Subs{\Desugar{\gamma}}{J_n}}$
    & by \cref{lemma:rtype-core-determinism} (core determinism)
    \\
    &iff&
    $\saysJ{\overline{\Icore}}{\Subs{\Desugar{\gamma}}{\Desugar{J_1}}\Subs{\Desugar{\gamma}}{\Desugar{J_n}}}$
    & since $\Desugar{J_i} = {J_i}$
    \\
    &iff&
    $\saysJ{\overline{\Icore}}{\Desugar{\Subs{\gamma}{J_1}}\dots\Desugar{\Subs{\gamma}{J_1}}}$
    & by \reflem{distributivity}
    \\
    &implies&
    $\saysJ{\overline{\Isurf}}{\Subs{\gamma}{J_1}\dots\Subs{\gamma}{J_n}}$
    & inductive hypothesis
  \end{Table}

  Also:
  \begin{Table}
    &&
    $\saysVJ{\overline{\Isurf}}{\seq{J}[n]}{J_0}$
    & by \refass{resugaring}
    \\
    &implies&
    $\saysVJ{\overline{\Isurf}}{\seq{\Subs{\gamma}{J}}[n]}{\Subs{\gamma}{J_0}}$
    & by \refass{substitution}
    \\
    &iff&
    $\saysVJ{\overline{\Isurf}}{\seq{\Subs{\gamma}{J}}[n]}{\Subs{\gamma}{\Jsurf}}$
    & equality
  \end{Table}

  Thus $\saysJ{\overline{\Isurf}}{\Jsurf}$ by \refass{composition}.
  \end{proof}
  \caption{Proof of \cref{thm:rtype-faithful}.} \label{fig:rtype-faithful}
  \end{Wide}
\end{flushleft}\end{figure*}

Furthermore, resugaring obeys \cref{goal:rtype-abstraction}, essentially by
construction:
\begin{lemma}
  Resugaring obeys \cref{goal:rtype-abstraction}: type rules for surface
  constructs never mention core constructs.
\end{lemma}
\begin{proof}
  Let $\ResugarTy{\Icore}{p_\Sc{lhs} \To p_\Sc{rhs}} = \seq{J} / J_\Sc{lhs}$
  be any surface rule. We aim to show that $\seq{J}$ and $J_\Sc{lhs}$ do
  not mention core constructs $P$. By \refass{resugaring},
  $\saysVD{\Icore}{\seq{J}}{\Desugar{J_\Sc{lhs}}}$, where $\seq{J}$ are all provable
  using \Code{t-premise}. We gave the \Code{t-premise} rule in \cref{sec:rtype-walkthrough},
  and generalize it in \cref{sec:rtype-fresh} and \cref{sec:rtype-globals}. However, in \emph{all} of its
  versions, the judgment must be over a surface term. Thus $\seq{J}$
  do not mention core constructs.

  Finally, the expression in $J_\Sc{lhs}$ is the \textsc{lhs} of a
  desugaring rule, and is thus by definition a surface term.
  Therefore, given our assumptions listed in this section, resugaring
  obeys \cref{goal:rtype-abstraction}.
\end{proof}



\section{Desugaring Features} \label{sec:rtype-desugaring}

There are several important features of desugaring that make the above
story more interesting. We describe them in this section.


\subsection{Calculating Types}
\label{sec:rtype-calctype}

Consider the desugaring of \Code{let} into the application of a
\Code{lambda}:
\[
\DesugarRule{let $x$ = $\alpha$ in $\beta$}
            {($\lambda$ $x:{\qmark}\,.$ $\beta$)($\alpha$)}
\]
What is the missing type? It needs to match the type of $\alpha$, but
there is no way to express this using the kind of desugaring rules we
have presented so far. We therefore extend the desugaring language
with a feature called \Code{calc-type}. In this example, it can be used
as follows:

$\LongDesugarRule{let $x$ = $\alpha$ in $\beta$}
                {calc-type $\alpha$ as $X$ in ($\lambda$ $x:X\,.$ $\beta$)($\alpha$)}$

This binds the type variable $X$ to the type of $\alpha$ in the
rest of the desugaring.

In general, \Code{calc-type} may be used in expression position on the
\Sc{rhs} of a desugaring rule, and its meaning is that:
\[\Code{calc-type $p_1$ as $t$ in $p_2$}\]
desugars to $p_2$, in which the type $t$ has been unified with the
type of $p_1$, thus allowing the free type variables of $t$ to be used
in $p_2$.\footnote{
\Code{calc-type} can also be used to force a more specific surface
  type rule than would be inferred. For example,
  \Code{(calc-type $\alpha$ as List<$X$> in ...)} will lead to a
  surface type rule that enforces that $\alpha$ is a list.
  This is used in the Haskell list comprehension example of
  \cref{sec:rtype-eval-case} and in the \Code{or} example of \cref{sec:rtype-arity}.
} Notice that this requires desugaring and type checking to be
interspersed. This is not surprising, since the desugaring of
\Code{let} involves determining a type.

This feature needs to be reflected in our type system. We do so with
the type rule:
\begin{prooftree}
  \RZero{\saysT{\Gamma}{p_1}{t_1}}
  \RZero{t_1 = t}
  \RZero{\saysT{\Gamma}{p_2}{t_2}}
  \RThree[t-calc-type]{\saysT{\Gamma}{\Code{(calc-type $p_1$ as $t$ in $p_2$)}}{t_2}}
\end{prooftree}

With this type rule, we can find a type derivation for \Code{let},
shown in \cref{fig:rtype-calc-type-ex}.
\begin{figure*}[h!]
  \begin{prooftree}
    \RZero{}
    \dashedLine\ROne[t-premise]{\saysTt{\Gamma}{$\alpha$}{A}}
    \RZero{\Code{A = t}}
    \RZero{}
    \dashedLine\ROne[t-premise]{\saysTt{\Gamma,\Code{x}:\Code{t}}{$\beta$}{D}}
    \ROne[t-lambda]{\saysTt{\Gamma}{($\lambda$ x:t. $\beta$)}{t $\to$ D}}
    \RZero{}
    \dashedLine\ROne[t-premise]{\saysTt{\Gamma}{$\alpha$}{t}}
    \RTwo[t-app]{\saysTt{\Gamma}{($\lambda$ x:t. $\beta$)($\alpha$)}{D}}
    \RThree[t-calc-type]{\saysTt{\Gamma}{
        (calc-type $\alpha$ as t in ($\lambda$ x:t. $\beta$) $\alpha$)}{D}}
    \ROne[t-let]{\saysTt{\Gamma}{\Code{let x = $\alpha$ in $\beta$}}{D}}
  \end{prooftree}
  \caption{Type derivation of \Code{let}}
  \label{fig:rtype-calc-type-ex}
\end{figure*}
It leads to the type rule:
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{$\alpha$}{A}}
  \RZero{\saysTt{\Gamma,\Code{x}:\Code{A}}{$\beta$}{B}}
  \RTwo[t-let]{\saysTt{\Gamma}{let x = $\alpha$ in $\beta$}{B}}
\end{prooftree}

Here we can see an advantage of type resugaring. As noted above, to
type check \Code{let} in the core, type checking and desugaring must
be interspersed. However, to type check \Code{let} in the surface,
only this resugared rule is needed.


\subsection{Recursive Sugars} \label{sec:rtype-recursion}

Consider boolean guards in Haskell list comprehensions, which are
defined by the desugaring rule (in Haskell's syntax):
\[\DesugarRule{[$\alpha$ | $\beta$, $\gamma$]}{if $\beta$ then [$\alpha$ | $\gamma$] else []}\]
This sugar, unlike those we have seen up to this point, is
defined recursively: its \Sc{rhs} contains a
list comprehension. Our resugaring algorithm, as described so far,
will fail to find a type derivation for this sugar. It will get to the
judgment $\saysT{\Gamma}{\Code{[$\alpha$ | $\gamma$]}}{\_}$,
but lack any way to prove this judgment, because
the \texttt{t-premise} rule does not match.

Our solution is to generalize the \texttt{t-premise} rule to allow any
judgment about a surface term to be
accepted as a premise. Notice that the term \Code{[$\alpha$ | $\gamma$]}
is a surface term: when desugaring, pattern variables such as $\alpha$ and
$\gamma$ will only ever be bound to surface terms, and thus they
themselves should be considered part of the surface language. We
therefore refine the \texttt{t-premise} rule as:
\begin{prooftree}
  \RZero{\text{fresh } x}
  \RZero{p \text{ is a surface term}}
  \dashedLine\RTwo[t-premise]{\saysT{\Gamma}{p}{x}}
\end{prooftree}
    

Furthermore, this is the most general rule we can make:
\cref{goal:rtype-abstraction} states that surface type rules must never
mention core constructs, so \texttt{t-premise} can allow judgments over
surface terms but nothing more.




\subsection{Fresh Variables} \label{sec:rtype-fresh}

Take the sugar \Code{const}, which produces a constant function:
\[
\DesugarRule{const $\alpha$}{$\lambda$ $x:\text{Unit}.$ $\alpha$}
\]

It is important that $x$ be given a fresh name, or else this
sugar might accidentally capture a user-defined variable called $x$
which is used in $\alpha$.
This is easy to add to desugaring: each desugaring rule
will specify a set of ``capturing'' variables that are \emph{not}
freshly generated, and all other introduced variables will be given
fresh names.\marginpar{%
Picking fresh names for sugar-introduced variables suffices
  for hygiene because our sugars are declared
  outside the language.}
(We use a capturing rather than fresh set to choose hygiene by
default.)

This feature must also be reflected in the surface type system.
First, let $\mathcal{F}$ be the set of introduced variables that are
not marked as captured. We then add the type rule:
\begin{prooftree}
  \RZero{\saysT{\Gamma}{p}{t}}
  \RZero{\hspace{-1em}p \text{ is a surface term}}
  \RZero{\hspace{-1em}\seq[1]{x}[n] \in \mathcal{F}}
  \RThree[t-fresh]{\saysT{\Gamma, x_1:t_1 \dots x_n:t_n}{p}{t}}
\end{prooftree}
to remove unnecessary fresh variables from the type environment, and
by modifying \Code{t-premise} to only work on judgments so limited:\marginpar{%
Our implementation combines \Code{t-fresh} and \Code{t-premise} into
one rule for convenience, but the effect is the same.
}
  
\begin{prooftree}
  \RZero{p \text{ is a surface term}}
  \RZero{\hspace{-1em}\Forall{x \in \Gamma} x \not\in \mathcal{F}}
  \RZero{\hspace{-1em}\text{fresh } x'}
  \dashedLine\RThree[t-premise]{\saysT{\Gamma}{p}{x'}}
\end{prooftree}

What exactly is \Code{t-fresh} saying?
It is a form of weakening, but with two extra restrictions.
First, the variables being weakened are variables that will be given
fresh names during desugaring. Second, the expression $e$ is a surface
term. Together, these imply that $e$ cannot contain $\seq[1]{x}[n]$,
so it \emph{should} be safe to remove them from $\Gamma$.
One way this could fail is if the language does not admit
weakening, for example if it has a linear type system.
We therefore assume that:
\begin{assumption}
  The rule:
  \begin{prooftree}
    \RZero{x \not\in \Gamma}
    \RZero{x \not\in e}
    \RZero{\saysT{\Gamma, x:t'}{e}{t}}
    \RThree{\saysT{\Gamma}{e}{t}}
  \end{prooftree}
  is admissible in the core type system.
\end{assumption}
This rule can be used to ``reverse'' any use of \Code{t-fresh}, so if
it is admissible then applying \Code{t-fresh} greedily can never lead
a derivation into a dead end.


\subsection{Globals}
\label{sec:rtype-globals}

Sugars may rely on library functions. For instance, Haskell's list
comprehension sugar makes use of the library function \Code{concatMap}
(which is \Code{map} followed by list concatenation). We therefore
allow the declaration of ``global'' names, together with their type,
with the understanding that this name will be available to the
desugared code (with the given type).\marginpar{%
The ability to reference ``globals'' is but a poor approximation to
  a macro system that allows macros and code to be interspersed, in
  which a macro may reference any identifier it is in scope of.
  However, type resugaring in this setting is a much harder
  problem which we leave to future work.
}

The declared globals effectively form a primordial type environment,
available in conjunction with the ordinary type environment. For
example, if \Code{+} desugars into a call to a global \Code{plus}, the
type rule for \Code{+} is actually (using \Code{N} as shorthand for \Code{Number}):
\begin{prooftree}
\RZero{\saysTt{\Code{plus}:\Code{N,N$\to$N},\;\Gamma}
  {$\alpha$}{N}}
\RZero{\saysTt{\Code{plus}:\Code{N,N$\to$N},\;\Gamma}
  {$\beta$}{N}}
\RTwo{\saysTt{\Code{plus}:\Code{N,N$\to$N},\;\Gamma}
  {$\alpha$ + $\beta$}{N}}
\end{prooftree}
However, this is both verbose and unusual, so we opt to leave the
$\Code{N,N$\to$N}$ implicit. We do so by adding the type rule:
\begin{prooftree}
  \RZero{globals[x] = t}
  \ROne[t-global]{\saysT{\Gamma}{x}{t}}
\end{prooftree}
which allows \Code{plus} to be left out of $\Gamma$.

\subsection{Variable Arities}\label{sec:rtype-arity}

We support syntactic constructs with variable arity by having a sort
called $e^{*}$ that represents a sequence of expressions:
\begin{Table}
  $e^{*}$ &$::=$& $\epsilon$      & empty sequence \\
          &$|$& $\cons{e}{e^{*}}$ & nonempty sequence \\
          &$|$& $\PVarA$          & pattern variable
\end{Table}
{SweetT} supports these sequences by providing:
\begin{itemize}
  \item The above grammar production, allowing a language's grammar to
    refer to $e^{*}$.
  \item Proper handling of sequences in the unification algorithm, allowing them to
    be resugared.
  \item Built-in operations for accessing the $n$'th element of a
    sequence, and for asserting that a type judgment holds for
    all expressions in a sequence.
\end{itemize}
{SweetT} likewise supports sequences of types, $t^{*}$,
and records of both expressions and types.

Using this feature, a simple variable-arity \Code{or} sugar can have
production rule \nodeTt{or}{$e^{*}$}, and desugaring rules:

  $\DesugarRule{\nodeTt{or}{\cons{$\PVarA$}{$\epsilon$}}}
              {$\PVarA$}$

  $\DesugarRule{\nodeTt{or}{\cons{$\PVarA$}{\cons{$\PVarB$}{$\PVarC$}}}}
              {if $\PVarA$ then true else
                \nodeTt{or}{\cons{$\PVarB$}{$\PVarC$}}}$

Type resugaring produces one type rule for each desugaring rule:
\begin{prooftree}
  \RZero{\saysT{\Gamma}{\alpha}\Code{A}}
  \ROne[sugar-or-1]{\saysT{\Gamma}{\nodeTt{or}{\cons{\PVarA}{\epsilon}}}\Code{A}}
\end{prooftree}
\begin{prooftree}
  \RZero{\saysT{\Gamma}{\nodeTt{or}{\cons{\PVarB}{\PVarC}}}{\Code{Bool}}}
  \RZero{\saysT{\Gamma}{\alpha}{\Code{Bool}}}
  \RTwo[sugar-or-2]{\saysT{\Gamma}{\nodeTt{or}{\cons{\PVarA}{\cons{\PVarB}{\PVarC}}}}{\Code{Bool}}}
\end{prooftree}

The first rule may appear to be too general, but it accurately reflects the
sugar as written: \nodeTt{or}{\cons{3}{$\epsilon$}} is a synonym for
3 and has type Number. However, we can statically restrict the
singleton \Code{or} to accept only booleans using \Code{calc-type}:

  $\DesugarRule{\nodeTt{or}{\cons{$\PVarA$}{$\epsilon$}}}
               {\texttt{calc-type $\PVarA$ as Bool in $\PVarA$}}$

\noindent
at which point the resugared type rule becomes:
\begin{prooftree}
  \RZero{\saysT{\Gamma}{\alpha}{Bool}}
  \ROne[sugar-or-1]{\saysT{\Gamma}{\nodeTt{or}{\cons{\PVarA}{\epsilon}}}{Bool}}
\end{prooftree}
as probably desired.


\section{Implementation}\label{sec:rtype-implementation}

We have implemented a prototype of our tool in PLT
Redex~\cite{redex}, a semantics engineering tool.
It can be found at \url{cs.brown.edu/research/plt/dl/pldi2018/}.
Among other features, Redex
allows one to define judgment forms, and given a judgment form
can search for derivations of it.

{SweetT} takes as input:
\begin{itemize}
\item The syntax of a language, given as a grammar in Redex.
\item Core language type rules, defined as a judgment form in Redex.
  We require that these rules be written using equality constraints:
  if two premises in a type rule would traditionally describe equality
  by repeating a type variable, SweetT instead requires that the
  rule be written using two different type variables, with an
  equality constraint between them---thus making the
  unification explicit.\marginpar{%
This is necessary because re-using the same type variable would
    invoke Redex's pattern-matching algorithm. This is usually
    sufficient, because Redex is meant to type a complete term.
    However, we are typing a partial term, and instead need a more
    general unification algorithm. So instead, {SweetT} gathers
    equations and performs unification itself.
  }
\item Desugaring rules, given by a \Sc{lhs} and \Sc{rhs}. Each
  rule has a \emph{capture list} of variables to be treated
  unhygienically, as described in \cref{sec:rtype-fresh}, and the \Sc{rhs} of a
  rule may make use of \Code{calc-type}, as described in
  \cref{sec:rtype-calctype}.
\item Type definitions of globals, as described in \cref{sec:rtype-globals}.
\end{itemize}

{SweetT} then provides a \Code{resugar} function that follows the
process outlined at the end of \cref{sec:rtype-walkthrough}, together with the extensions
described in \cref{sec:rtype-desugaring}. If \Code{resugar} succeeds, it produces the
resugared type rule, as well as the derivation which led to it. If it
fails, it announces that no derivation was found (or, less likely,
that more than one was found, in violation of \refass{unique-rule}).

\Refass{resugaring} is essentially a specification for \Code{resugar}, and we believe
our implementation obeys this property. We provide empirical evidence
for this fact, and for the power of {SweetT}, in the next section.

\section{Evaluation}

There is no standard benchmark for work in this area. Therefore,
we evaluate our approach in two ways.
First, we try resugaring on a number of sugars we create atop existing
\emph{type systems}, to ensure
that it can support that variety of type systems. Second, we show some
\emph{case studies} which validate that it can handle interesting
sugars.

\subsection{Type Systems}\label{sec:rtype-eval-type}

We evaluate {SweetT} by implementing a number of type systems from
Types and Programming Languages (\textsc{tapl}~\cite{tapl}).
We tested the type systems in Part II of \textsc{tapl}
(except for references, pg. 167), as well as two
later systems (subtyping and existentials). Altogether, this is:
\begin{itemize}[noitemsep]
\item Booleans (pg. 93)
\item Numbers (pg. 93)
\item Simply Typed Lambda Calculus (pg. 103)
\item Unit (pg. 119)
\item Ascription (pg. 122)
\item Let binding (pg. 124)
\item Pairs (pg. 126)
\item Tuples (pg. 128)
\item Records (pg. 129)
\item Sums (pg. 132)
\item Variants (pg. 136)
\item General recursion (pg. 144)
\item Lists (pg. 147)
\item Error handling (pg. 174)
\item Algorithmic subtyping (pg. 212)
\item Existential types (pg. 366)
\end{itemize}
We tested each type system by picking one or more sugars that made use
of its features, resugaring them to obtain type rules, and validating
the resulting type rules by hand. All of them resugared
successfully.

Three type systems required extending {SweetT}'s unification
algorithm: records and lists needed builtin support, as described in
\cref{sec:rtype-arity}, and subtyping required adding subtyping constraints,
as well as a new \Code{t-sub-premise} rule.\marginpar{%
The \Code{t-sub-premise} rule is like \Code{t-premise}, but for
  subtyping judgements instead of type judgements.
}
References (pg. 167) would have required changing the form of
judgments, from $\saysT{\Gamma}{e}{t}$ to
$\saysT{\Gamma,\gamma}{e}{t}$ where $\gamma$ is a store environment,
which would be a more extensive change.

\subsection{Case Studies}\label{sec:rtype-eval-case}

We describe six case studies below.

The first three are simpler than the rest. We describe them briefly,
and show them in \cref{fig:rtype-examples-1,fig:rtype-examples-2}. For each, the figure first shows
the relevant core language type rules, then the sugar, then its core
derivation, and finally the resugared type rule. To make them fit, we
show all of the derivations \emph{after} unification, eliminating
equality constraints.

The last three case studies are more complex, so we discuss them more
but do not show their type derivations (which do not fit on a page).


\paragraph{Letrec}
The \Code{letrec} sugar (\cref{fig:rtype-examples-1}) introduces
recursive bindings using $\lambda$ and \Code{fix} (the fixpoint
operator).

\paragraph{$\lambda$ret}
The \Code{$\lambda$ret} sugar (\cref{fig:rtype-examples-1}) implements
\Code{return} in functions using \textsc{tapl}-style exceptions (using
\Code{String} as the fixed exception type). The variable \Code{return}
is marked as capturing in the sugar, and thus appears explicitly in
the resulting type rule.

\paragraph{Upcast}
The \Code{upcast} sugar (\cref{fig:rtype-examples-2}) converts an expression
to a supertype of its type via $\eta$-expansion. Notice that the core
language type system contains subtyping judgements, as mentioned in
\cref{sec:rtype-eval-type}.


\paragraph{Foreach}

We consider a functional \Code{foreach} loop, that performs a map on a
list, and also provides \Code{break} within the loop. If \Code{break}
is called, the loop halts and returns the elements processed so far.
Its desugaring is:
\begin{verbatim}
foreach x list body
=>
letrec loop : ((List a) -> (List b) -> (List b)) =
  (λ (lst : (List a)) (acc : (List b))
    if (isnil lst)
    then acc
    else
      try
        let break = (λ (_ : Unit) raise "") in
        let x = head lst in
        loop (tail lst) (cons body acc)
      with (λ (_ : String) acc))
in reverse (loop list nil)
\end{verbatim}
where \Code{reverse} is a global (\cref{sec:rtype-globals})
with type \Code{[i] -> [i]}.
In addition, this sugar is declared to capture the
variable \Code{break} (see \cref{sec:rtype-fresh}).

The resugared type rule for \Code{foreach} is show in \cref{fig:rtype-foreach}.
It demonstrates how different variables must be handled.
In the desugaring, when \Code{body} is used, several variables are in scope:
\Code{loop}, \Code{lst}, \Code{acc}, \Code{break}, and \Code{x}.
However, in the resugared type rule, only \Code{break} and \Code{x}
are in scope in the judgment for \Code{body}: \Code{x} because
it is an argument to the sugar, and \Code{break} because it is
declared as capturing.

\begin{figure*}
\begin{prooftree}
  \RZero{\saysTtt{\Gamma}{$list$}\Code{List $D$}}
  \RZero{\saysTtt{\Gamma,x:D,break:(\Code{Unit} \to B)}{$body$}{F}}
  \RTwo[t-foreach]{\saysTtt{\Gamma}{foreach $x$ $list$ $body$}\Code{List $F$}}
\end{prooftree}
\caption{\Code{foreach} type rule}\label{fig:rtype-foreach}
\end{figure*}


\paragraph{Haskell List Comprehensions}

List comprehensions~\cite[section 3.11]{haskell-language} are
given by the following transformation:
\begin{verbatim}
  [e | True]         = [e]
  [e | q]            = [e | q, True]
  [e | b, Q]         = if b then [e | Q] else []
  [e | p <- l, Q]    = let ok p = [e | Q]
                           ok _ = []
                       in concatMap ok l
  [e | let decls, Q] = let decls in [e | Q]
\end{verbatim}
A Haskell list comprehension has the form \Code{[e | Q]}, where
\Code{e} is an expression and \Code{Q} is a list of \emph{qualifiers}.
There are three kinds of qualifiers, which are visible in the rules
above: (i) boolean guards \Code{b} perform a filter; (ii) generators
\Code{p <- l} perform a map; and (iii) \Code{let decls} declare local
bindings.

We will ignore first two rules (which are uninteresting base cases),
and focus on the last three, that introduce qualifiers.
To resugar these three kinds of qualifiers, we declare
\Code{concatMap} as a global with type \Code{(i -> [o]) -> [i] -> [o]},
as described in \cref{sec:rtype-globals}.
We also simplify the generator desugaring to
consist of a single variable binding, because that is what is
available in the \textsc{tapl} core language we are desugaring to.
Finally, we use \Code{calc-type} (\cref{sec:rtype-calctype}) to determine the
type of elements in generators.
Thus, we are resugaring these slightly modified rules:
\begin{verbatim}
  [e | b, Q] = if b then [e | Q] else []
  [e | x <- l, Q] = calc-type l as [t] in
      concatMap (\(x :: t) -> [e | Q]) l
  [e | let x = e2, Q] = (let x = e2 in [e | Q])
\end{verbatim}
{SweetT} resugars these rules, producing the following type
rules (transcribed into Haskell syntax)\marginpar{``hlc'' stands for ``Haskell
list comprehension''.}:

\begin{prooftree}
  \RZero{\saysTtt{\Gamma}{[$e$ | $Q$]}{$ C$}}
  \RZero{\saysTtt{\Gamma}{$b$}{Bool}}
  \RTwo[t-hlc-guard]{\saysTtt{\Gamma}{[$e$ | $b$, $Q$]}{$ C$}}
\end{prooftree}

\begin{prooftree}
  \RZero{\saysTtt{\Gamma,x:t}{[$e$ | $Q$]}{[$o$]}}
  \RZero{\saysTtt{\Gamma}{$l$}{[$t$]}}
  \RTwo[t-hlc-gen]{\saysTtt{\Gamma}{[$e$ | $x$ <- $l$, $Q$]}{[$o$]}}
\end{prooftree}

\begin{prooftree}
  \RZero{\saysTtt{\Gamma,x:A}{[$e$ | $Q$]}{$ B$}}
  \RZero{\saysTtt{\Gamma}{$e_2$}{$ A$}}
  \RTwo[t-hlc-let]{\saysTtt{\Gamma}{[$e$ | let $x$ = $e_2$, $Q$]}{$ B$}}
\end{prooftree}



\paragraph{Newtype}

Let us now look at a desugaring of \Code{new-type} into existential
types. The core language will have constructs for packing and unpacking
existentials:
\begin{prooftree}
  \RZero{\saysTtt{\Gamma}{$e$}{[$X$ \mapsto $U$]$t$}}
  \ROne[t-pack]{\saysTtt{\Gamma}
    {pack ($U$ $e$) as ($\exists$ $X$ $t$)}
    \texttt{($\exists$ $X$ $t$)}}
\end{prooftree}

\begin{prooftree}
  \RZero{\saysTtt{\Gamma}{$e_1$}\texttt{($\exists$ $X$ $t_1$)}}
  \RZero{\saysTtt{\Gamma,x:t_1}{$e_2$}\texttt{$t_2$}}
  \RTwo[t-unpack]{\saysTtt{\Gamma}
    {unpack $e_1$ as ($\exists$ $X$ $x$) in $e_2$}
    \texttt{$t_2$}}
\end{prooftree}

We define a \Code{new-type} sugar that presents a concrete type \Code{T}
as an abstract type \Code{X}, and provides wrapping and unwrapping
functions (with user-chosen names) that convert from
\Code{T} to \Code{X} and from \Code{X} to \Code{T} respectively. The desugaring is:
\begin{lstlisting}
new-type ($wrap$ $unwrap$) of $T$ as $X$ in $body$
$\To$
unpack (pack ($T$ (pair id id)
        as ($\exists$ $X$ (Pair ($T \to X$) ($X \to T$)))))
as ($\exists$ X w)
in let $wrap$ = fst w in
   let $unwrap$ = snd w in
   $body$
\end{lstlisting}
where \Code{id} is a global (\cref{sec:rtype-globals})
identity function.

This sugar is successfully resugared to give the type rule:

\begin{prooftree}
  \RZero{\saysTtt{\Gamma,u:X \to T,w:T \to X}{$body$}{A}}
  \ROne[t-new-type]{\saysTtt{\Gamma}
    {new-type ($w$ $u$) of $T$ as $X$ in $body$}
    {A}}
\end{prooftree}
Notice that this type rule does not mention existentials in any way,
thereby hiding the underlying implementation method and sparing the
programmer from needing to understand anything but \Code{new-type} itself.



\section{Related Work}
\label{s:rtype-relwork}

% Compare desugaring power? Most of these are written in host language.

\paragraph{Work with the Same Goal}

We know of a few pieces of work with the same end goal as us: to take a
language with syntactic sugar, and type check it without allowing for
the possibility of a user seeing a type error in the core language.

In Lorenzen and Erdweg's \emph{SoundExt}~\cite{SoundExt},
desugaring comes \emph{before} type checking.
Their formalism takes (i) a
type system for the core language, (ii) a type system for the surface
language, and (iii) desugaring rules. It then statically verifies that
the surface type system is consistent with the core type system.  More
precisely, they ensure that, for any program, \emph{if} that program
type-checks in the surface language, \emph{then} its desugaring must
type-check in the core language. Our approach has a critical
advantage over theirs: we do not require
type rules to be written for the surface language, but rather infer
them. This simplifies the process of extending the language, restoring
the adage ``oh, that's \emph{just} syntactic sugar''. We believe this
is especially valuable to authors of, say, domain-specific languages,
who are experts in a domain but may not be in the definition of type
systems.

Lorenzen and Erdweg's later \emph{SoundX}~\cite{SoundX} shows how
to \emph{integrate} desugaring and
type rules, so that the \emph{same} rule can serve both to extend
desugaring and to extend the type system. Essentially, the \Sc{lhs} of
a desugaring rule is given as a type rule, and the \Sc{rhs} is given as
an expression (per usual). Again, the difference with our work is that
we do not require type rules to be written for the surface language.

%``https://www.cs.indiana.edu/~sabry/papers/macroml.pdf''
%``Explicitly Heterogeneous Metaprogramming with MetaHaskell''

In a similar vein, both Granz et al.'s MacroML~\cite{MacroML} and Mainland's
MetaHaskell~\cite{MetaHaskell} are staged programming languages. They provide
the same guarantee as SoundExt and SoundX: in the words of Mainland, ``Well-typed
metaprograms should only generate well-typed object terms.''
Therefore, as with our work, a user is guaranteed never to see a type
error in desugared code.  Unlike SweetT, these staged systems allow macro
definitions to be interspersed with code. On the other hand, they do
not allow macros to check the type of an expression (as in our
\Code{calc-type}, \cref{sec:rtype-calctype}), or to inspect code (they can
only \emph{build} code up from smaller fragments).

Omar et al. provide a syntactic extension mechanism for Wyvern called
``type-specific languages'' (TSLs)~\cite{Wyvern-TSL}. They note that syntactic extensions often
conflict with each other, but can be resolved based on the type that
the syntax is checked against. As a simple example, Python uses
the same syntax \Code{\{...\}} for both sets and dictionaries. The syntax
\Code{\{\}} is thus ambiguous, but this could be resolved by checking
whether the type context expected a set or a dictionary. This is the
purpose of TSLs. Like MacroML and MetaHaskell, Wyvern TSLs can only
construct code, and cannot inspect or deconstruct it. (This is
sufficient for their main intended use case, which is defining
language literals.)

Finally, Heeren et al., and later Serrano and Hage, show how to
augment a type system with new hand-written error
messages~\cite{type-error-inference,type-error-edsl}. They do so in
the context of embedded \textsc{dsl}s that are implemented without
syntactic sugar (which is why their work does not immediately apply to
our situation). When coding in such an embedded \textsc{dsl},
programmers would normally be confronted with type errors arising from
the implementation of the \textsc{dsl}. This line of work allows the
\textsc{dsl} author to write custom error messages that instead frame
the error in terms of the \textsc{dsl}.


\paragraph{Work with Similar Goals}

There are many systems that type check
\emph{after} desugaring; they
potentially show a programmer a type error
in code the programmer did not write.
Some of these are type systems
retrofitted onto languages with macros, such as  
Type Racket~\cite{languages-as-libraries} and
Typed Clojure~\cite{typed-clojure}.
They at best use sourcemaps, providing an accurate line
number for a potentially confusing message.
There are also metaprogramming
systems added to languages with types, such as those of
Haskell~\cite{TemplateHaskell}, Ocaml~\cite{Camlp5}, and
Scala~\cite{scala-macros}.
They permit grammar extension,
and allow desugaring to be defined as an arbitrary function
from \textsc{ast} to \textsc{ast}.
However, while their metasyntactic types capture the syntactic category of an
expression (for instance \Code{Exp} vs. \Code{Name} in TemplateHaskell),
they do not reflect the object types (e.g., expressions of type
\Code{Int} vs. expressions of type \Code{String}).
As a result, they need to type check after desugaring.
(Contrast this to MetaHaskell and MacroML, described above.)

% For example, in Typed Racket, the macro
% \Code{(define-syntax-rule (of-one f) (f "one"))},
% when invoked with \Code{(of-one add1)} produces an error message that
% blames the string \Code{"one"}. This is misleading, however: it is
% most likely the \emph{argument} to \Code{of-one} that needs to be corrected.
% In contrast, SweetT infers a type for \Code{of-one} that expects a
% function of type \Code{String $\to$ A}, which would instead blame \Code{add1}.

Fish and Shivers' Ziggurat~\cite{ziggurat} is a framework for defining a
hierarchy of language levels, that makes it easy to attach static
analysis of any sort to each level. However, it does not analyze the
analysis, so it is possible for one level's analysis to conflict
with that of another.

Similar work has been done for \emph{scope rules}. For an overview,
see \cref{sec:rscope-related}.


%% This would be a nice table, but I'm not sure how to categorize some
%% of its entries. E.g., does MetaHaskell infer sugar types?
%% Yes, but not explicitly?
%% Lorenzen says that MetaHaskell has dynamic soundness, but I'm not
%% sure I believe him.
%% 
%% \begin{figure*}
%% \begin{tabular}{l | l l l l l l}
%%   \textbf{Work} & \textbf{Domain} & \textbf{w.r.t. Desugar} & \textbf{Inference?}
%%   & \textbf{Static?} & \textbf{Safe?} & \textbf{Context Info?} \\
%%   \hline
%%   $\lambda_m$, Romeo & scope & before & \xmark & \cmark & \cmark & \textbf{-} \\
%%   Scope resugaring & scope & before & \cmark & \cmark & \cmark & \textbf{-} \\
%%   \hline
%%   SoundX & types & before & \xmark & \cmark & \cmark & \xmark \\
%%   SoundExt & types & before & \xmark & \cmark & \cmark & \cmark \\
%%   Camlp4, TemplateHaskell, MetaHaskell & types & after & \xmark & \xmark & \cmark & \xmark \\
%%   MetaML & types & before & \xmark & \cmark & \cmark & \xmark \\
%%   Scala Macros, Wyvern TLSs & types & before & \xmark & \xmark & \cmark & \cmark \\
%%   Ziggurat & any & before \& after & \xmark & \cmark & \xmark & \xmark \\
%%   \textbf{SweetT} & types & before & \cmark & \cmark & \cmark & \cmark \\
%% \end{tabular}

%% \caption{Related Work}
%% \label{fig:rtype-related-work}
%% \end{figure*}


\paragraph{Work with a Different Goal}

Our work could be contrasted with Chang et al.'s \emph{Turnstile}~\cite{turnstile}.
Turnstile is a macro-based framework for defining type systems.
However, while it uses desugaring in the \emph{implementing} language,
it has no support for sugar in the \emph{implemented} language. To
this end, it is a competitor to other lightweight language modeling
tools (like Redex), and we could have used Turnstile
instead of Redex as the basis for our work (we settled on Redex for
various practical reasons).

\section{Discussion and Conclusion}

In this chapter, we have presented an algorithm and system for type resugaring: given
syntactic sugar over a typed language, it reconstructs type rules for
that sugar. These rules can be added to a type-checker to check the
sugar directly (and produce error messages at the level of the sugar,
rather than its expanded code), and also be added to the documentation
of the surface language. We show that the system can handle a variety
of language constructs, and that it successfully suppresses the
details of what the sugar expands to.

We discussed restrictions on the pattern language of sugars in \cref{sec:rtype-req-desugar}
and the underlying type system in \cref{sec:rtype-req-type,sec:rtype-req-resugar}. We also presented
some limitations of the implementation in \cref{sec:rtype-eval-type}. All of
these are worth investigating to make this idea even more broadly
applicable.

In principle, not much in our work has specifically been about
\emph{types}. Therefore, this idea could just as well be applied to
other syntax-driven deductive systems, such as a natural
semantics~\cite{gk:natural-semantics}
or structural operational semantics~\cite{gdp:struct-op-sem}. This would
correspondingly enable the creation of semantic rules at the level of
the surface language, which can not only enrich a language's
documentation but also facilitate its use in, say, a proof assistant.

\begin{figure*}[h]
\BoxedHeading{Sugars: Letrec and $\lambda$ret}

\TinyHeading{Core Type Rules:}\newline
\begin{minipage}[b]{0.3\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma,\Code{x}:\Code{T}}{e}{U}}
    \ROne[t-lambda]{\saysTt{\Gamma}{$\lambda$ x:T. e}{(T $\to$ U)}}
  \end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.5\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma}{f}{T $\to$ U}}
    \RZero{\saysTt{\Gamma}{e}{T}}
    \RTwo[t-apply]{\saysTt{\Gamma}{(f e)}{U}}
  \end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.4\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma}{e}{T $\to$ T}}
    \ROne[t-fix]{\saysTt{\Gamma}{(fix e)}{T}}
  \end{prooftree}
\end{minipage}

\begin{minipage}[b]{0.45\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma}{e}{Str}}
    \ROne[t-raise]{\saysTt{\Gamma}{(raise e)}{T}}
  \end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.45\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma}{e}{T}}
    \RZero{\saysTt{\Gamma}{e$_\text{catch}$}{Str $\to$ T}}
    \RTwo[t-try]{\saysTt{\Gamma}{try e with e$_\text{catch}$}{T}}
  \end{prooftree}
\end{minipage}

\TinyHeading{Desugaring Rules:}
\[
\qquad\DesugarRule
    {letrec x : C = a in b}
    {($\lambda$ x:C. b) (fix ($\lambda$ x:C. a))}
\]
\begin{Codes}
\(\lambda\)ret x:T. b
\(\To\) \(\lambda\) x:T. try (let return = (\(\lambda\) v:Str. raise v) in b) with (\(\lambda\) v:Str. v)
\end{Codes}
\qquad \Code{$\lambda$ret} is a function with \Code{return}
automatically bound (i.e., marked as capturing) to escape from the function.

\TinyHeading{Core Derivations:}\newline
\begin{prooftree}
  \RZero{}
  \dashedLine\ROne[t-premise]{\saysTt{\Gamma,\Code{x}:\Code{C}}{b}{D}}
  \ROne[t-lambda]{\saysTt{\Gamma}{($\lambda$ x:C. b)}{C $\to$ D}}
  \RZero{}
  \dashedLine\ROne[t-premise]{\saysTt{\Gamma,\Code{x}:\Code{C}}{a}{C}}
  \ROne[t-lambda]{\saysTt{\Gamma}{($\lambda$ x:C. a)}{C $\to$ C}}
  \ROne[t-fix]{\saysTt{\Gamma}{(fix ($\lambda$ x:C. a))}{C}}
  \RTwo[t-apply]{\saysTt{\Gamma}{(($\lambda$ x:C. b) (fix ($\lambda$ x:C. a)))}{D}}
  \ROne[t-letrec$^\rightarrow$]{\saysTt{\Gamma}{letrec x : C = a in b}{D}}
\end{prooftree}
{\tiny
\begin{prooftree}
  \RZero{}
  \ROne[t-id]{\saysTt{\Gamma,\Code{x}:\Code{T},\Code{v}:\Code{Str}}{v}{Str}}
  \ROne[t-raise]{\saysTt{\Gamma,\Code{x}:\Code{T},\Code{v}:\Code{Str}}{raise v}{A}}
  \ROne[t-$\lambda$]{\saysTt{\Gamma,\Code{x}:\Code{T}}{($\lambda$ v:Str. raise v)}{Str $\!\!\to\!\!$ A}}
  \RZero{}
  \ROne[t-prem.]{\saysTt{\Gamma,\Code{x}:\Code{T},\Code{return}:\Code{Str $\to$ A}}{b}{Str}}
  \RTwo[t-let]{\saysTt{\Gamma,\Code{x}:\Code{T}}{(let return = ($\lambda$ v:Str. raise v) in b)}{Str}}
  \RZero{}
  \ROne[t-id]{\saysTt{\Gamma,\Code{x}:\Code{T},\Code{v}:\Code{Str}}{v}{Str}}
  \ROne[t-$\lambda$]{\saysTt{\Gamma,\Code{x}:\Code{T}}{($\lambda$ v:Str. v)}{Str $\!\!\to\!\!$ Str}}
  \RTwo[t-try]{\saysTt{\Gamma,\Code{x}:\Code{T}}{(try (let return = ($\lambda$ v:Str. raise v) in b) with ($\lambda$ v:Str. v))}{Str}}
  \ROne[t-$\lambda$]{\saysTt{\Gamma}{$\lambda$ x:T. (try (let return = ($\lambda$ v:Str. raise v) in b) with ($\lambda$ v:Str. v))}{T $\!\!\to\!\!$ Str}}
  \ROne[t-$\lambda$ret$^\rightarrow$]{\saysTt{\Gamma}{($\lambda$ret x:T. b)}{T $\!\!\to\!\!$ Str}}
\end{prooftree}
}

\TinyHeading{Resugared Type Rules:}\newline
  \begin{prooftree}
    \RZero{\saysTt{\Gamma,\Code{x}:\Code{C}}{a}{C}}
    \RZero{\saysTt{\Gamma,\Code{x}:\Code{C}}{b}{D}}
    \RTwo[t-letrec]{\saysTt{\Gamma}{letrec x : C = a in b}{D}}
  \end{prooftree}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma,\,\Code{x}:\Code{T},\,\Code{return}:\Code{(Str $\to$ A)}}{b}{Str}}
    \ROne[t-$\lambda$ret]{\saysTt{\Gamma}{($\lambda$ret x:T. b)}{T $\to$ Str}}
  \end{prooftree}

\caption{Derivation examples}
\label{fig:rtype-examples-1}
\end{figure*}


\begin{figure*}[h]
\BoxedHeading{Sugar: Upcast}

\TinyHeading{Core Type Rules:}\newline
\begin{minipage}[b]{0.3\textwidth}
  \begin{prooftree}
    \RZero{\Code{x:T $\in$ $\Gamma$}}
    \ROne[t-id]{\saysTt{\Gamma}{x}{T}}
  \end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.4\textwidth}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma,\Code{x}:\Code{T}}{e}{U}}
    \ROne[t-lambda]{\saysTt{\Gamma}{$\lambda$ x:T. e}{(T $\to$ U)}}
  \end{prooftree}
\end{minipage}
  \begin{prooftree}
    \RZero{\saysTt{\Gamma}{f}{T $\to$ U}}
    \RZero{\saysTt{\Gamma}{e}{T$'$}}
    \RZero{\Code{T$'$ $<:$ T}}
    \RThree[t-apply]{\saysTt{\Gamma}{(f e)}{U}}
  \end{prooftree}

\TinyHeading{Desugaring Rule:}
\[
\DesugarRule
    {upcast a as C}
    {($\lambda$ x:C. x) a}
\]

\TinyHeading{Core Derivation:}
\begin{prooftree}
  \RZero{}
  \ROne[t-id]{\saysTt{\Gamma,\Code{x}:\Code{C}}{x}{C}}
  \ROne[t-lambda]{\saysTt{\Gamma}{($\lambda$ x:C. x)}{C $\to$ C}}
  \RZero{}
  \dashedLine\ROne[t-premise]{\saysTt{\Gamma}{a}{A}}
  \RZero{}
  \dashedLine\ROne[t-sub-premise]{\Code{A $<:$ C}}
  \RThree[t-apply]{\saysTt{\Gamma}{(($\lambda$ x:C. x) a)}{C}}
  \ROne[t-upcast$^\rightarrow$]{\saysTt{\Gamma}{upcast a as C}{C}}
\end{prooftree}

\TinyHeading{Resugared Type Rule:}
\begin{prooftree}
  \RZero{\saysTt{\Gamma}{a}{A}}
  \RZero{\Code{A $<:$ C}}
  \RTwo[t-upcast]{\saysTt{\Gamma}{upcast a as C}{C}}
\end{prooftree}

\caption{Derivation examples (cont.)}
\label{fig:rtype-examples-2}
\end{figure*}

\newpage
\section{Demos}

This section shows SweetT in action. \cref{fig:rtype-demo} shows a sample
usage of SweetT, and \cref{fig:rtype-sample1,fig:rtype-sample2,fig:rtype-sample3} show
many sugars and their resugared type rules. These sugars are mostly
very simple; their purpose is not to show that SweetT can handle
interesting sugars (this is what the case studies of
\cref{sec:rtype-eval-case} are for), but rather to show that it can handle
several different type systems. In particular, these sugars, together
with those shown earlier in this chapter, make use of all of the TAPL type
system features listed in \cref{sec:rtype-eval-type}.
\begin{figure*}[h]
\paragraph{An example of SweetT usage, that defines a 'not' sugar:}
\begin{lstlisting}
  #lang racket

  (require redex)
  (require "../resugar.rkt")
  
  (define-resugarable-language demo
    #:keywords(if true false Bool)
    (e ::= ....
       (if e e e))
    (v ::= ....
       true
       false)
    (t ::= ....
       Bool)
    (s ::= ....
       (not s)))
  
  (define-core-type-system demo
    [($\vdash$ $\Gamma$ e_1 t_1)
     ($\vdash$ $\Gamma$ e_2 t_2)
     ($\vdash$ $\Gamma$ e_3 t_3)
     (con (t_1 = Bool))
     (con (t_2 = t_3))
     ------ t-if
     ($\vdash$ $\Gamma$ (if e_1 e_2 e_3) t_3)]
  
    [------ t-true
     ($\vdash$ $\Gamma$ true Bool)]
  
    [------ t-false
     ($\vdash$ $\Gamma$ false Bool)])
  
  (define rule_not
    (ds-rule "not" #:capture()
             (not ~a)
             (if ~a false true)))
  
  (view-sugar-type-rules demo $\vdash$ (list rule_not))
\end{lstlisting}
\paragraph{Infers the following resugared type rule:}
\input{img/not.tex}
\caption{Sample SweetT usage}\label{fig:rtype-demo}
\end{figure*}


\begin{SidewaysFigure}
\begin{tabular}{l l l @{}}
  \Sample{Booleans}
  & \begin{BVerbatim}
(ds-rule "unless" #:capture()
  (unless ~a ~b)
  (if ~a unit ~b))
    \end{BVerbatim}
  & \Img{unless}
  \\
  \Sample{Nats}
  & \begin{BVerbatim}
(ds-rule "ifzero" #:capture()
  (ifzero ~a ~b ~c)
  (if (iszero ~a) ~b ~c))
\end{BVerbatim}
  & \Img{ifzero}
  \\
  \Sample{STLC}
  & \begin{BVerbatim}
(ds-rule "let" #:capture()
  (let x = ~a in ~b)
    (calctype ~a as t in
      ((λ (x : t) ~b) ~a)))
\end{BVerbatim}
  & \Img{let}
  \\
  \Sample{Unit}
  & \begin{BVerbatim}
(ds-rule "thunk" #:capture()
  (thunk ~a)
  (λ (x : Unit) ~a))
\end{BVerbatim}
  & \Img{thunk}
  \\
  \Sample{Ascription}
  & \begin{BVerbatim}
(ds-rule "sametype" #:capture()
  (sametype ~a ~b)
  (calctype ~b as x_t in
    (~a as x_t)))
\end{BVerbatim}
  & \Img{sametype}
  \\
  \Sample{Let}
  & \begin{BVerbatim}
(ds-rule "or" #:capture()
  (or ~a ~b)
  (let x = ~a in (if x x ~b)))
\end{BVerbatim}
  & \Img{or}

\end{tabular}

\caption{Sample sugars, pg.1}\label{fig:rtype-sample1}
\end{SidewaysFigure}




\begin{SidewaysFigure}
\begin{tabular}{l l l @{}}

  \Sample{Pair}
  & \begin{BVerbatim}
(ds-rule "let-pair" #:capture()
  (let-pair x y = ~a in ~b)
  (calctype ~a as (Pair t_1 t_2) in
    (let p = ~a in
      (let x = (fst p) in
        (let y = (snd p) in
          ~b)))))
    \end{BVerbatim}
  & \Img{let-pair}
  \\

  \Sample{Tuple}
  & \begin{BVerbatim}
(ds-rule "tuple2" #:capture()
  (tuple2 ~a ~b)
  (tuple (cons ~a (cons ~b ϵ))))
    \end{BVerbatim}
  & \Img{tuple2}
  \\

  \Sample{Record}
  & \begin{BVerbatim}
(ds-rule "rec-point" #:capture()
  (rec-point ~a ~b)
  (record (field x ~a (field y ~b ϵ))))
    \end{BVerbatim}
  & \Img{rec-point}
  \\

  \Sample{Sum}
  & \begin{BVerbatim}

(ds-rule "sum-map" #:capture()
  (sum-map ~a ok ~b)
  (case ~a of
    (inl err => (inl err))
    (inr ok => (inr ~b))))
    \end{BVerbatim}
  & \Img{sum-map}
      
\end{tabular}
\caption{Sample sugars, pg.2}\label{fig:rtype-sample2}
\end{SidewaysFigure}

\begin{SidewaysFigure}
\begin{tabular}{l l l @{}}

  \Sample{Variant}
  & \begin{BVerbatim}

;Show that variants make sums irrelevant
(ds-rule "inl" #:capture()
  (inl* ~l)
  (calctype ~l as t_l in
    (variant l = ~l as
      (Variant (field l t_l
               (field r t_r ϵ))))))
    \end{BVerbatim}
  & \Img{inl}
  \\
  \Sample{Variant}
  & \begin{BVerbatim}
(ds-rule "inr" #:capture()
  (inr* ~r)
  (calctype ~r as t_r in
    (variant r = ~r as
      (Variant (field l t_l
               (field r t_r ϵ))))))
    \end{BVerbatim}
  & \Img{inr}
  \\
  \Sample{Variant}
  & \begin{BVerbatim}
(ds-rule "case" #:capture()
  (case* ~e of (x => ~l) (y => ~r))
  (case ~e of (cons (l = x => ~l)
              (cons (r = y => ~r) ϵ))))
    \end{BVerbatim}
  & {\scriptsize\Img{case}}
  \\
  \Sample{Fixpoint}
  & \begin{BVerbatim}
(ds-rule "letrec" #:capture()
  (letrec x : ~t = ~a in ~b)
    ((λ (x : ~t) ~b)
      (fix (λ (x : ~t) ~a)))))
    \end{BVerbatim}
  & \Img{letrec}

\end{tabular}
\caption{Sample sugars, pg.3}\label{fig:rtype-sample3}
\end{SidewaysFigure}
